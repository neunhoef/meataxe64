#
# $Id: indicate_with_element,v 1.1 2002/03/20 18:42:30 jon Exp $
#
# Script to find the indicator of an irreducible representation
# Assumes a and b in standard base form
#
# Inputs
# $1: generator a
# $2: generator b
# $3: element to use to get null vector
# $4: generator a in dual representation
# $5: generator b in dual representation
# $6: script used to create null element
# $7: initial memory (optional)
#
# Return codes
# 1: error in parameters
# 0: ok
#
usage="$0: usage: $0 <a> <b> <e> <a dual> <b dual> <script> [<memory>]"
if [ $# -ne 6 -a $# -ne 7 ]; then
  echo $usage
  exit 1;
fi
. functions
a=$1
b=$2
a_d=$4
b_d=$5
e=$3
script=$6
if [ -e $a -a -e $b -a -e $e -a -e $a_d -a -e $b_d ]; then
  q=`zprime $a`
  nor=`znor $a`
  noc=`znoc $a`
  if [ $nor -ne $noc ]; then
    echo "$0: $a is not square"
    exit 1
  fi
  if [ $nor -ne `znor $b` -o $nor -ne `znoc $b` -o $nor -ne `znor $e` -o $nor -ne `znoc $e` -o $nor -ne `znor $a_d` -o $nor -ne `znoc $a_d` -o $nor -ne `znor $b_d` -o $nor -ne `znoc $b_d` ]; then
    echo "$0: $a, $b, $e, $a_d, $b_d are not compatible"
    exit 1
  fi
else
  echo "$0: missing files $a, $b or $e"
  exit 1
fi
if [ $# -eq 7 ]; then
  memory=$7
else
  memory=200
fi
if [ -e ${a}_${script} -o -L ${a}_${script} ]; then
  rm ${a}_${script}
fi
ln -s ${a} ${a}_${script}
tmp=tmp${PPID}
S=${tmp}.3
Q=${tmp}.4
sb=${tmp}.0
# TODO: cut down the amount of work here, we don't need the invert, multiplies etc
x=`base $e $a_d $b_d $sb $S`
ret=$?
if [ $ret -eq 0 ]; then
  if diff $a ${sb}_sb_1 1>/dev/null 2>&1; then
    if diff $b ${sb}_sb_2 1>/dev/null 2>&1; then
      if [ $nor -eq 1 ]; then
        echo indicator +
        rm -f ${tmp}.*
        if [ -e ${a}_+ -o -L ${a}_+ ]; then
          rm ${a}_+
        fi
        ln -s $a ${a}_+
        exit 0
      fi
      zqf $S $Q
      a_t=${tmp}.5
      b_t=${tmp}.6
      ztr $a $a_t $memory
      ztr $b $b_t $memory
      i=0
      q=`zprime $a`
      while [ $i -lt $q ]; do
        zsid $q $nor $noc $i ${tmp}.7
        zad $Q ${tmp}.7 ${tmp}.8
        preserves ${tmp}.8 $S ${tmp}.7 $a $a_t $memory
        ret=$?
        if [ $ret -eq 0 ]; then
          preserves ${tmp}.8 $S ${tmp}.7 $b $b_t $memory
          ret=$?
          if [ $ret -eq 0 ]; then
            echo indicator +
            rm -f ${tmp}.*
            if [ -e ${a}_+ -o -L ${a}_+ ]; then
              rm ${a}_+
            fi
            ln -s $a ${a}_+
            exit 0
          elif [ $ret -eq 1 ]; then
            rm -f ${tmp}.*
            exit 1
          fi
        elif [ $ret -eq 1 ]; then
          rm -f ${tmp}.*
          exit 1
        fi
# Try next diagonal
        let i=$i+1
      done
      echo indicator -
      rm -f ${tmp}.*
      if [ -e ${a}_- -o -L ${a}_- ]; then
        rm ${a}_-
      fi
      ln -s $a ${a}_-
      exit 0
    fi
  fi
elif [ $ret -ne 255 ]; then
  echo base return $ret, terminating
  exit 1
fi
rm -f ${tmp}.*
if [ -e ${a}_o -o -L ${a}_o ]; then
  rm ${a}_o
fi
ln -s $a ${a}_o
echo indicator o
