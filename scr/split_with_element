#!/bin/sh
#
# $Id: split_with_element,v 1.21 2002/11/29 19:19:01 jon Exp $
#
# Script to split a representation given a particular element to work from
#
# Inputs
# $1: element with which to split
# $2: output filename base
# $3: call count to prevent looping
# $4: ignore pathology (very high nullity)
# $5: name for subspace
# $6: generator a
# $7-: other generators
#
# outputs will be of the form <$2>_<nor>_<subnor>_<x>
# where nor is number of rows, and subnor is
# the number of rows in the sub or quotient space as appropriate
#
#
# Return codes
# 1: error in parameters
# 0: success
# 253: nullity 0
# 254: did not split
# 255: irreducible
#
. functions
usage="$0: usage: $0 <e> <output_stem> <count> <ignore pathology> <subspace> <a> [<other generators>]"
if [ $# -lt 6 ]; then
  echo "$usage"
  exit 1;
fi
e=$1
o=$2
c=$3
path=$4
s=$5
a=$6
shift 6
if [ -e $a -a -e $e ]; then
  q=`zprime $e`
  nor=`znor $a`
  noc=`znoc $a`
  if [ $nor -ne $noc ]; then
    echo "$0: $a is not square"
    exit 1
  fi
  if [ 1 -eq $q ]; then
    echo "$0: $e cannot be a map"
    exit 1
  fi
  if [ $noc -ne `znoc $e` ]; then
    echo "$0: $a and $e are not compatible"
    exit 1
  fi
else
  echo "$0: missing files $a or $e"
  exit 1
fi
tmp=tmp${PPID}
#echo Using tmp stem $tmp
#
# rm -f ${tmp}*
# Check above first
#
memory=200
ok=0
nullity=0
while [ 0 -eq $ok ]; do
  nullity=`zns -m $memory $e ${tmp}.2 2>&1`
  ret=$?
  if [ $ret -eq 0 ]; then
    ok=1
  else
    if [ $ret -eq 2 ]; then
      let memory=`more_memory $memory`
#     echo Allocating more memory for zns, now $memory
    else
      rm -f ${tmp}*
      echo $nullity
      exit 1
    fi
  fi
done
echo nullity $nullity
if [ $nullity -eq 0 ]; then
  echo Failed to split
  rm -f ${tmp}*
  exit 253
fi
ok=0
count=$nullity
if [ $count -gt 5 ]; then
  let count2=$count*$count
  if [ $count2 -gt $nor -a 0 -ne $path ]; then
# Pathological element, no point in trying 
    rm -f ${tmp}*
    exit 254
  fi
  count=5
  if [ 0 -ne $path ]; then
    echo Restricting span to 5 vectors
  else
# Avoid overflow
    if [ 2 -eq $q ]; then
      count=15
    elif [ 3 -le $q ]; then
      count=8
    fi
    if [ $count -gt $nullity ]; then
      count=$nullity
    fi
  fi
fi
#echo Considering $vectors vectors
if [ 0 -eq $c ]; then
  zspan ${tmp}.2 ${tmp}.3 $count
  if [ $? -ne 0 ]; then
    rm -f ${tmp}*
    exit 1
  fi
  vectors=`znor ${tmp}.3`
else
# Only consider one vector when called from irred
  cp ${tmp}.2 ${tmp}.3
  vectors=1
fi
vector=0;
while [ $vector -lt $vectors ]; do
  split=0
#
# Pick vector $vector from ${tmp}.3 and attempt to spin
#
#  echo Trying vector $vector
  zsel ${tmp}.3 ${tmp}.4 $vector
  mem_ok=0
  while [ 0 -eq $mem_ok ]; do
    dim=`zmsp -m $memory ${tmp}.4 $s $a $* 2>/dev/null`
    ret=$?
    if [ $ret -eq 0 ]; then
      mem_ok=1
    elif [ $ret -eq 2 ]; then
      let memory=`more_memory $memory`
#     echo Allocating more memory for zmsp, now $memory
    else
      echo Split failed with some sort of error $ret
      rm -f ${tmp}*
      exit 1
    fi
  done
  let vector=$vector+1
  if [ $dim -lt $nor ]; then
    split=1
    break
  fi
  if [ 0 -ne $c ]; then
# No need to check multiple vectors from irred
    break
  fi
  echo Resplitting with vector $vector
done
if [ $split -ne 0 ]; then
  if [ 0 -ne $c ]; then
# Called from irred, just return the subspace
    rm -f ${tmp}*
    exit 0
  fi
else
# echo checking if irreducible
  if [ $c -eq 0 ]; then
#   echo split_with_element calls irred
    irred $e $o $memory $s $a $*
    ret=$?
#   echo irred returns result $ret
    if [ $ret -eq 255 ]; then
      echo irreducible $a $* of dimension $nor found
      rm -f ${tmp}*
      exit 255
    elif [ $ret -eq 254 ]; then
      rm -f ${tmp}*
      exit 254
    elif [ $ret -eq 253 ]; then
      echo "Serious bug found in split/irred (nullity 0 passed to irred)"
      rm -f ${tmp}*
      exit 1
    elif [ $ret -eq 0 ]; then
#     echo irred finbds a split, calling dual_subspace
      codim=`znor $s`
      dim=`dual_subspace $s ${tmp}.5 $memory`
      ret=$?
      if [ 0 -ne $ret ]; then
        rm -f ${tmp}*
        exit $ret
      fi
      let total=$dim+$codim
      if [ $total -ne $nor ]; then
        echo "dual_subspace produces a subspace of dimension $dim from one of dimension $codim in whole space of dimension $nor (serious bug)"
        rm -f ${tmp}*
        exit 1
      fi
#     echo dual_subspace produces a subspace of dimension $dim from one of dimension `znor $s` in whole space of dimension $nor
      cp -p ${tmp}.5 $s
    else
      rm -f ${tmp}*
      exit $ret
    fi
  else
    if [ $count -eq $nullity ]; then
      rm -f ${tmp}*
      exit 255
    else
      rm -f ${tmp}*
      exit 254
    fi
  fi
fi
let codim=$nor-$dim
ss_name=`new_name ${o} ${nor} ${dim}`
qs_name=`new_name ${o} ${nor} ${codim}`
if [ $dim -eq $codim ]; then
  ss_name=${ss_name}_a
  qs_name=${qs_name}_b
fi
echo Obtained a subspace ${ss_name} of dimension $dim, quotient ${qs_name} codimension $codim
split_with_subspace $a $s ${ss_name}_1 ${qs_name}_1 $memory
x=1
while [ 0 -ne $# ]; do
  let x=$x+1
  split_with_subspace $1 $s ${ss_name}_$x ${qs_name}_$x $memory
  shift
done
rm -f ${tmp}*
exit 0
