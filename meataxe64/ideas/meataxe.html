<html>
<head>
<title>
A new (2002) meataxe
</title>
</head>
<body>
<table>
<tr><td>Title:</td><td>A new (2002) meataxe</td></tr>
<tr><td>Author:</td><td><a href=mailto:jgt@pobox.com>Jon Thackray</a><td>
<tr><td>Version:</td><td>1</td></tr>
<tr><td>Id:</td><td>$Id: meataxe.html,v 1.87 2017/01/10 08:08:49 jon Exp $</td></tr>
<tr><td>Date:</td><td>20020513</td></tr>
<tr><td>Status:</td><td>Draft</td></tr>
</table>
<h1>Contents</h1>
<ol>
<li><a href="#Preface">Preface</a></li>
<li><a href="#Purpose">Purpose</a></li>
<li><a href="#Structure">Structure</a></li>
<li><a href="#Executables">Executables</a></li>
<li><a href="#Scripts">Scripts</a></li>
<li><a href="#Caveats">Caveats, folk lore and common usage</a></li>
</ol>
<a name="Preface">
<h1>Preface</h1>
</a>
<p>
This work arose out of a desire to build on work originally done for
my thesis, along with work done towards the end of 1998. The thesis
work was the first meataxe, collaboratively produced with Richard
Parker, and used to solve three main problems. The first of these was
the outstanding issue of the 2-modular characters of M24, left
incomplete in Gordon James' thesis. The second was the completion of
the 2-modular characters of McL, a part of my own thesis. The third
was the final stage of the existence proof of J4, which required
finding a 4995 dimensional submodule of the skew square of the
conjectured 112 dimensional representation of J4 over GF(2).
</p>
<p>
In 1998, I again collaborated with Richard Parker, to produce the
beginnings of a distributed meataxe for handling larger dimensional
problems, essentially by carving up the matrices concerned into
submatrices, and then applying the standard operations (multiply,
Gaussian elimination) to them. The example produced was a
multiplication program, consisting of a master work distribution
program, and a number of slaves, and this was used to demonstrate
multiplication of the two monster generators during the 1998 Niklaus
conference weekend.
</p>
<p>
In August 2001, I decided to revisit the 1998 work. I realised that in
terms of a full meataxe, we had very little, and so took this as an
opportunity to explore a new design of my own. With the exception of
the monster generation code, everything in this meataxe is my own
original work. Towards the end of 2001 I had enough of a meataxe to
split permutation representations, and had computed the composition
factors for my test case, the three permutation representations of He
available on the Birmingham Atlas website.
</p>
<p>
At the end of November 2001, I communicated with Rob Wilson at
Birmingham, telling him what I had done and what capabilities my
system had. He pointed out that the full table for He was known, and
suggested that I look at some of the outstanding indicator problems on
the MOC website at Aachen. I added the necessary extensions to my
system, and set to work. Since starting, at the time of writing, my
system has computed indicators for 10504 for Suz, 36398 for Co2, 88000
for Co3, and 83948 for Co2. It has also demonstrated the existence of
and found indicators for 8 new 2-modular representations of Co1, and
is in the process of finding a ninth.
</p>
<a name="Purpose">
<h1>Purpose</h1>
</a>
<p>
This meataxe is intended to address problems in modular representation
theory, typically finding and proving irreducible representations,
computing indicators and dealing with other problems where the
representation rather than the character is under study.
</p>
<p>
This meataxe is intended to be used with current and near future
hardware and software, and to take advantage of its current and
expected capabilities. No attempt is made to address old hardware or
software. The existing meataxes address this area perfectly well, and
there is little to be gained by the use of old (and almost certainly
inadequate) systems to address current problems.
</p>
<p>
With the above goals in mind, the following decisions have been taken
in the design of this meataxe
</p>
<ul>
<li>
The external printed form as per sources on Birmingham website is
maintained. In particular, header is a two digit nod (number of
digits), followed by three six digit fields, the prime power, nor
(number of rows) and noc (number of columns) (as far as I understand
it). nod determines how many digits will be consumed per matrix entry.
Matrices are printed at a maximum of 80 characters per line. It is my
intention to relax the input format restrictions, which were derived
from earlier Fortran/assembler implementations of the meataxe. In
particular, these formats do not handle permutations on sets of a
million or more points.
</li>
<li>
Internally, all matrices are held as arrays of unsigned ints. There is
no intentional assumption on the size of int, however, since the
system has only been tested on Intel x86 architectures, it is likely
that some unintentional assumptions have crept in. Also, since the
system has only been tested on little endian machines, it is possible
that some unintientional assumptions on endianness have also appeared.
Field values are packed into ints, as bitfields, with the least
significant bits corresponding to lower column numbers. Some wastage
occurs at bitfield and word boundaries, if the prime power does not
require a number of bits which is a power of two (eg 3, 5, 7, 8). This
contrasts with meataxe 6, which appears to use unsigned chars in a bit
big endian fashion, does not use bitfields, and packs values as power
series in the field order.
</li>
<li>
Externally, binary matrices are held in essentially the same form as
internally, except that they are always little endian. Endian
conversion takes place on input and output. This allows different
endian machines, eg Sparcs and PCs, to use the same binary format
whilst achieving internal efficiency. Each binary matrix contains a
three word header, consisting of prime power (field order), nor, noc,
in little endian format. Again, this is in contrast to meataxe 6. As
far as I can tell from the source I have, meataxe 6 did not consider
the problem of a consistent external binary representation, and hence
big and little endian machines would be unable to operate on the same
file data.
</li>
<li>
-1 is represented as p-1, and indeed all elements of GF(p) are
represented as their integer minimal non-negative coset
representatives.
</li>
<li>
Permutations are represented (in printed form) as a list of images of
1 ... n, rather than in cycle notation for example.
</li>
<li>
Permutations are represented internally as a header with nor = range
size, noc = image size (to allow non-bijective maps), and prime 1.
Unfortunately, there is currently no way of representing this in the
printed form.
</li>
<li>
Split matrices for the extended operations system are represented as a
directory containing a special file called map. map has two six digit
fields as its first row, indicating respectively the number of rows
and columns into which the matrix has been split. The remaining lines
of map are one per row, and each entry is the name of a file
representing that row and column position in the matrix. The names
used are typically of the form n_m, although this is not a requirement.
</li>
<li>
Return code zero indicates success. Return code 1 is a general
failure, eg bad parameters, incompatible parameters etc. Return code 2
is out of memory, from which we may recover by rerunning with more
memory. High value codes come mainly from scripts and indicate other
failures which generally correspond to inappropriate operations, eg
nullity zero when nullity non-zero was required.
</li>
<li>
Permutations may be used in many places where matrices would normally
be required, and may be added and multiplied. In the case of multiply,
two permutations multiply to give a further permutation. Two
permutations may not be added, since the result will not be a
permutation and there is no way of indicating the field. However, one
can convert permutations to matrices at any time as required.
</li>
</ul>
<p>
The decision to use a slightly less space efficient internal format is
justified as follows. Accessing values from bitfields is more
efficient than from polynomials in the field order. As the problem
size grows, the time complexity is cubic whereas the space complexity
is quadratic. Hence we should always trade space inefficiency for time
efficiency, given the predictions of Moore's law, which has both
growing at the same rate, factor two per 18 months.
</p>
<p>
Similarly, the use of the machine word internally allows for the
production of very efficient add, scale and scaled add code, dependent
on the field order. Thus operations for low field orders, and
particularly GF(2), can be made very efficient.
</p>
<p>
On a related note, the system tries to make use of knowledge of sparse
matrices where possible. Matrices in standard base format are sparse,
and so multiplications involving these as the left hand operand will
be correspondingly quick. It can sometimes therefore be worthwhile to
transform AB, where B is sparse, into the multiplication of the
transposes followed by a further transposition. Transposition is
quadratic complexity whereas multiplication is cubic, so the larger
the dimension, the more worthwhile such a transformation becomes.
</p>
<a name="Structure">
<h1>Structure</h1>
</a>
<p>
This meataxe is built from two types of component. The first is the
executable, addressing functions such as find the nullspace of this
matrix, or add these two matrices to give a third. The second is the
script. Scripts glue together executables, and sometimes other
scripts, to give higher functions, such as find all the composition
factors of this representation and keep a record of the unqiue factors
in a standard basis, with indicators. The scripts are written in unix
shell. The executables are written in ANSI C. Consistent compilation
is achieved using GNU make. This does not limit the meataxe to being
built and run on unix systems, since projects such as cygwin provide a
very good unix like environment on Win32 for example. However, at the
time of writing, I do not have access to a Win32 platform, and hence
the necessay minor makefile subsection to enable Win32 operation has
not been written.
</p>
<p>
Executables are in turn produced by linking together modules with
specific functions. An example of a module would be the row operations
as required by add, multiply and Gaussian elimination. Each module has
a C source file, and a header. An executable will also have a source
file with no corresponding header, responsible for the very top level
of the executable and generally doing little more than some elementary
parameter checking and a function call to the main body of the
executable.
</p>
<p>
The system is built with all warnings enabled, subject to the
constraint that it must be possible to fix any warning found within
the code, so as to obtain a compilation with no warnings or errors.
Thus warning levels that produce warnings in the standard headers (eg
W4 in visual C++) are not used. All warnings are regarded as errors,
and should be fixed, even of the fix has no real semantic effect on
the code. This is a policy to which I personally work, and one which I
would expect to be maintained should implementation work on this
meataxe become collaborative.
</p>
<a name="Executables">
<h1>Executables</h1>
</a>
<p>
There are a great many executables, some of which are very commonly
used, and some only rarely. I document them in alphabetical order.
Executables operating on standard (ie not split) matrices all begin
with the letter 'z', whereas executables operating on split matrices
begin with the letter 'e'. In cases where this distinction is
inapplicable, eg explode a matrix, the input type determines the
starting letter. Thus we have zex for explode, and eim for implode.
</p>
<p>
Output on stdout is expected program output, eg the rank of a matrix.
Output on stderr is error diagnostic information.
</p>
<p>
There are some parameters which are applicable to all executables.
These also have environemnt variable setting mechanisms. Parameters on
the command line override those in the environemnt, which in turn
override the program defaults.
<table>
<thead>
<td>
Command line
</td>
<td>
Environment variable
</td>
<td>
Meaning
</td>
</thead>
<tr>
<tr>
<td>
-m &lt;memory&gt;
</td>
<td>
mtx_memory
</td>
<td>
The amount of memory to be used
</td>
</tr>
<tr>
<td>
-q
</td>
<td>
mtx_quiet
</td>
<td>
Turn off verbose mode
</td>
</tr>
<tr>
<td>
-v
</td>
<td>
mtx_verbose
</td>
<td>
Turn on verbose mode
</td>
</tr>
</table>
</p>
<ol>
<li><a href="#dtou">dtou</a></li>
<li><a href="#ead">ead</a></li>
<li><a href="#ect">ect</a></li>
<li><a href="#eid">eid</a></li>
<li><a href="#eim">eim</a></li>
<li><a href="#eip">eip</a></li>
<li><a href="#emu">emu</a></li>
<li><a href="#esad">esad</a></li>
<li><a href="#esid">esid</a></li>
<li><a href="#etr">etr</a></li>
<li><a href="#monst">monst</a></li>
<li><a href="#sns">sns</a></li>
<li><a href="#srn">srn</a></li>
<li><a href="#stop">stop</a></li>
<li><a href="#zad">zad</a></li>
<li><a href="#zah">zah</a></li>
<li><a href="#zbase">zbase</a></li>
<li><a href="#zcfl">zcfl</a></li>
<li><a href="#zchar">zchar</a></li>
<li><a href="#zcheck">zcheck</a></li>
<li><a href="#zconj">zconj</a></li>
<li><a href="#zclean">zclean</a></li>
<li><a href="#zct">zct</a></li>
<li><a href="#zcv">zcv</a></li>
<li><a href="#zdiag">zdiag</a></li>
<li><a href="#zdiff">zdiff</a></li>
<li><a href="#zdiffd">zdiffd</a></li>
<li><a href="#zex">zex</a></li>
<li><a href="#zexport">zexport</a></li>
<li><a href="#zfe">zfe</a></li>
<li><a href="#zfln">zfln</a></li>
<li><a href="#zflnf">zflnf</a></li>
<li><a href="#zfn">zfn</a></li>
<li><a href="#zfo">zfo</a></li>
<li><a href="#zformat">zformat</a></li>
<li><a href="#zfr">zfr</a></li>
<li><a href="#zid">zid</a></li>
<li><a href="#zimport">zimport</a></li>
<li><a href="#zip">zip</a></li>
<li><a href="#ziv">ziv</a></li>
<li><a href="#zivf">zivf</a></li>
<li><a href="#zjoin">zjoin</a></li>
<li><a href="#zlp">zlp</a></li>
<li><a href="#zlpf">zlpf</a></li>
<li><a href="#zlv">zlv</a></li>
<li><a href="#zmsb">zmsb</a></li>
<li><a href="#zmsbf">zmsbf</a></li>
<li><a href="#zmsp">zmsp</a></li>
<li><a href="#zmspf">zmspf</a></li>
<li><a href="#zmvp">zmvp</a></li>
<li><a href="#zmu">zmu</a></li>
<li><a href="#znoc">znoc</a></li>
<li><a href="#znor">znor</a></li>
<li><a href="#zns">zns</a></li>
<li><a href="#znsf">znsf</a></li>
<li><a href="#zntco">zntco</a></li>
<li><a href="#zpfl">zpfl</a></li>
<li><a href="#zpco">zpco</a></li>
<li><a href="#zpcv">zpcv</a></li>
<li><a href="#zpofp">zpofp</a></li>
<li><a href="#zpr">zpr</a></li>
<li><a href="#zprime">zprime</a></li>
<li><a href="#zpro">zpro</a></li>
<li><a href="#zproj">zproj</a></li>
<li><a href="#zps">zps</a></li>
<li><a href="#zqf">zqf</a></li>
<li><a href="#zqs">zqs</a></li>
<li><a href="#zrand">zrand</a></li>
<li><a href="#zranks">zranks</a></li>
<li><a href="#zre">zre</a></li>
<li><a href="#zrestrict">zrestrict</a></li>
<li><a href="#zrn">zrn</a></li>
<li><a href="#zrnf">zrnf</a></li>
<li><a href="#zrranks">zrranks</a></li>
<li><a href="#zrsums">zrsums</a></li>
<li><a href="#zrsumsf">zrsumsf</a></li>
<li><a href="#zsad">zsad</a></li>
<li><a href="#zscript">zscript</a></li>
<li><a href="#zsel">zsel</a></li>
<li><a href="#zsid">zsid</a></li>
<li><a href="#zsign">zsign</a></li>
<li><a href="#zsignf">zsignf</a></li>
<li><a href="#zsing">zsing</a></li>
<li><a href="#zsize">zsize</a></li>
<li><a href="#zskcu">zskcu</a></li>
<li><a href="#zskfi">zskfi</a></li>
<li><a href="#zskfo">zskfo</a></li>
<li><a href="#zskse">zskse</a></li>
<li><a href="#zsksi">zsksi</a></li>
<li><a href="#zsksq">zsksq</a></li>
<li><a href="#zsl">zsl</a></li>
<li><a href="#zspan">zspan</a></li>
<li><a href="#zss">zss</a></li>
<li><a href="#zsums">zsums</a></li>
<li><a href="#zsumsf">zsumsf</a></li>
<li><a href="#zsv">zsv</a></li>
<li><a href="#zsymb">zsymb</a></li>
<li><a href="#zsymsq">zsymsq</a></li>
<li><a href="#ztco">ztco</a></li>
<li><a href="#ztcocon">ztcocon</a></li>
<li><a href="#ztcv">ztcv</a></li>
<li><a href="#zte">zte</a></li>
<li><a href="#ztmu">ztmu</a></li>
<li><a href="#ztr">ztr</a></li>
<li><a href="#ztrace">ztrace</a></li>
<li><a href="#ztrecover">ztrecover</a></li>
<li><a href="#ztsp">ztsp</a></li>
<li><a href="#ztspf">ztspf</a></li>
<li><a href="#zttov">zttov</a></li>
<li><a href="#zvp">zvp</a></li>
<li><a href="#zvpf">zvpf</a></li>
<li><a href="#zvtot">zvtot</a></li>
<li><a href="#zwords">zwords</a></li>
</ol>
<ul>
<li>
<h3><a name="dtou">dtou</a></h3>
Purpose: Convert DOS style line termination to unix style line
termination.
<table>
<thead>
<tr>
<td valign=top>Parameters:</td>
</tr>
</thead>
<tr>
<td valign=top>1</td><td valign=top>input file</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>output file</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: This is just a utility program to assist with down loading
of human readable files from eg the Birmingham Atlas Site, using
Windows based browsers.
</li>
<li>
<h3><a name="ead">ead</a></h3>
Purpose: Addition of exploded matrices.
<table>
<thead>
<tr>
<td valign=top>Parameters:</td>
</tr>
</thead>
<tr>
<td valign=top>1</td><td valign=top>First addend directory</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Second addend directory</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Result (sum) directory</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: This is a part of the (as yet incomplete) exploded matrix
suite. Although it acts on exploded matrices, it is not distributed,
as it did not seem worthwile expending the effort to make it so in
this case. If it is felt to be worthwhile, a modified version of the
<a href="#emu">emu</a> command program would be required. The slave
would run as is, without modification. Note that all three parameter
directories must exist, this program will not create them.
</li>
<li>
<h3><a name="ect">ect</a></h3>
Purpose: Count the number of non-zero entries in an exploded matrix
<table>
<thead>
<tr>
<td valign=top>Parameters:</td>
</tr>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input directory</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The number of non-zero entries</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: This is a part of the (as yet incomplete) exploded matrix
suite. Although it acts on exploded matrices, it is not distributed,
as it did not seem worthwile expending the effort to make it so in
this case. If it is felt to be worthwhile, a modified version of the
<a href="#emu">emu</a> command program would be required. The slave
would also require modification. The purpose of this program is to
give the user some idea of how expensive operations such as multiply
will be with this matrix as the left hand operand. The cost of
multiply is roughly proportional to the number of non-zero entries in
the left hand operand. In some circumstances, when the right hand
operand is sparse and the left hand operand is not, it may make sense
to transpose both operands, multiply in the reverse order and
transpose the result.
</li>
<li>
<h3><a name="eid">eid</a></h3>
Purpose: Create an exploded identity matrix
<table>
<thead>
<tr>
<td valign=top>Parameters:</td>
</tr>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Field order. This should be a prime power</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Number of rows</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Number of columns</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Number of rows/columns in each submatrix. This will be
rounded up to occupy full words</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Output matrix directory</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program.</td>
</tr>
</table>
Commentary: This is a part of the (as yet incomplete) exploded matrix
suite. Note that the output parameter directory must exist, this
program will not create it.
</li>
<li>
<h3><a name="eim">eim</a></h3>
Purpose: Implode exploded matrix
<table>
<thead>
<tr>
<td valign=top>Parameters:</td>
</tr>
</thead>
<tr>
<td valign=top>1</td><td valign=top>output matrix</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Input directory</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: Take a matrix in exploded form, and deliver a single
standard form matrix. All submatrices in the exploded matrix should
have the same field order. Submatrices in the same row should have the
same number of rows, and submatrices in the same column should have
the same number of columns.
</li>
<li>
<h3><a name="eip">eip</a></h3>
Purpose: Exploded input of permutation to matrix
<table>
<thead>
<tr>
<td valign=top>Parameters:</td>
</tr>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Textual input permutation</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Output directory</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Field order</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Number of rows/columns in each submatrix. This will be
rounded up to occupy full words</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: This is a part of the (as yet incomplete) exploded matrix
suite. Note that the output parameter directory must exist, this
program will not create it.
</li>
<li>
<h3><a name="emu">emu</a></h3>
Purpose: Exploded multiply
<table>
<thead>
<tr>
<td valign=top>Parameters:</td>
</tr>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input directory 1</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Input directory 2</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Output directory</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Directory for temporary files</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Limit on the number of jobs to be active or waiting at
any time</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>Some general progress commentary</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: This is a part of the (as yet incomplete) exploded matrix
suite. Note that the output and temporary parameter directories must
exist, this program will not create them. The program works in
conjunction with a number of slaves, communicating with them via a
command file in the directory in which it and the slaves were started.
A locking protocol similar to that used by exim is used to ensure
serialised access to the command file. It would appear that there is
still some sort of intermitttent fault in this area. Jobs which are
marked complete in the command file are moved into a separate file of
jobs done, thus limiting the size of the command file according to the
limit specified. <a href="#emu">Emu</a> attempts always to schedule
jobs which will reduce the number of temporary files, and will
therefore place new additions at the top of the command file, whereas
new multiplications are placed at the bottom.
</li>
<li>
<h3><a name="esad">esad</a></h3>
Purpose: Exploded scaled add. The scalar applies to parameter 1
<table>
<thead>
<tr>
<td valign=top>Parameters:</td>
</tr>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input directory 1</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Input directory 2</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Output directory</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Scalar</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: This is a part of the (as yet incomplete) exploded matrix
suite. Although it acts on exploded matrices, it is not distributed,
as it did not seem worthwile expending the effort to make it so in
this case. If it is felt to be worthwhile, a modified version of the
<a href="#emu">emu</a> command program would be required. The slave
would also require modification, as it does not yet support scale
factors. Note that all three parameter directories must exist, this
program will not create them.
</li>
<li>
<h3><a name="esid">esid</a></h3>
Purpose: Exploded scaled identity matrix
<table>
<thead>
<tr>
<td valign=top>Parameters:</td>
</tr>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Field order. This should be a prime power</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Number of rows</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Number of columns</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Output directory</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Number of rows/columns in each submatrix. This will be
rounded up to occupy full words</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Scalar</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: This is a part of the (as yet incomplete) exploded matrix
suite. Note that the output parameter directory must exist, this
program will not create it.
</li>
<li>
<h3><a name="etr">etr</a></h3>
Purpose: Exploded transpose
<table>
<thead>
<tr>
<td valign=top>Parameters:</td>
</tr>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input directory</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Output directory</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: This is a part of the (as yet incomplete) exploded matrix
suite. Although it acts on exploded matrices, it is not distributed,
as it did not seem worthwile expending the effort to make it so in
this case. If it is felt to be worthwhile, a modified version of the
<a href="#emu">emu</a> command program would be required. The slave
would run as is, without modification. Note that all parameter
directories must exist, this program will not create them.
</li>
<li>
<h3><a name="monst">monst</a></h3>
Purpose: Produce monster generators over GF(2) in 196882 dimensions
<table>
<thead>
<tr>
<td valign=top>Parameters:</td>
</tr>
</thead>
<tr>
<td valign=top>1</td><td valign=top>a or b</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: This code is mainly derived from the monster element
production program used at the 1998 Niklaus conference in Aachen to
demonstrate exploded matrix multiplication. Much redundant code has
been removed, and the output has been modified to conform to the new
meataxe, but the underlying algorithm is essentially unchanged from
the original Parker/Wilson code. A split of 20000 is assumed for the
output. The program must be run within a directory containing the
necesary data files, which can be obtained from the Birmingham atlas
ftp site, in the directory JGT.
</li>
<li>
<h3><a name="sns">sns</a></h3>
Purpose: Simple nullspace
<table>
<thead>
<tr>
<td valign=top>Parameters:</td>
</tr>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input matrix</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Nullspace</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The nullity</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for matrix plus workspace</td>
</tr>
</table>
Commentary: This is a simple nullspace program, without grease,
performing a naive Gaussian elimination to calculate nullspaces. Its
main use has been to check the validity of results from the more
sophisticated nullspace programs.
</li>
<li>
<h3><a name="srn">srn</a></h3>
Purpose: Simple rank
<table>
<thead>
<tr>
<td valign=top>Parameters:</td>
</tr>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input matrix</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The rank</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for matrix plus workspace</td>
</tr>
</table>
Commentary: cf <a href="#sns">sns</a>, a simple version of rank using
naive ungreased Gaussian elimination for consistency checking and
debugging.
</li>
<li>
<h3><a name="stop">stop</a></h3>
Purpose: Kill an exploded operation slave.
<table>
<thead>
<tr>
<td valign=top>Parameters:</td><td valign=top>None</td>
</tr>
</thead>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: This program is intended to perform a safe update to the
exploded operation command file requesting a slave to die. Killing a
slave explicitly, eg by control-C will possibly leave a lock
permanently acquired by the killed process. However, so far this
program is untested, pending completion of the exploded operations
part of this work.
</li>
<li>
<h3><a name="zad">zad</a></h3>
Purpose: Add two matrices to give a third
<table>
<thead>
<tr>
<td valign=top>Parameters:</td>
</tr>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input matrix 1</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Input matrix 2</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Output matrix</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: Just addition. The matrices should be of the same
dimension. Either matrix may be replaced by a permutation subject to
the row and column constraints. It is not possible to add two
permutations (however, multiplying one of them by an identity matrix
will deliver a matrix, which can then be added to the other).
</li>
<li>
<h3><a name="zah">zah</a></h3>
Purpose: Add header
<table>
<thead>
<tr>
<td valign=top>Parameters:</td>
</tr>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input header</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Input matrix</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Output matrix</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: This is a recovery program, intended for recovering
intermediate files produced by the file based programs such as <a
href="#zmspf">zmspf</a> in the case that they might be useful. A
header in the correct format for <a href="#zcv">zcv</a> should be
provided in parameter one descriing the contents of parameter 2. Some
rudimentary consistency checks are performed, but in the end, caveat
emptor applies. For use by experts only.
</li>
<li>
<h3><a name="zbase">zbase</a></h3>
Purpose: Produce a set of vectors giving a basis from a possibly
dependent set of vectors
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input vectors</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Temporary workspace directory</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Output vectors</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The dimension of the space spanned</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for matrix plus workspace</td>
</tr>
</table>
Commentary: This produces a basis, in echelised form, from a dependent
set, eg V + W, where the sum is not direct, as might be produced by
<a href="#zjoin">zjoin</a>.
</li>
<li>
<h3><a name="zcfl">zcfl</a></h3>
Purpose: Create a filter list
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Field size</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Number of generators</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: This is part of a suite of three programs used when
searching for delta words for tensor condensation. See <a
href=#zfn>zfn</a> for a full description of the purpose of the suite.
This program creates the initial filter list, and a matrix over the
feld size given in parameter 1, with number of columns given by
parameter 2. The output consists of every non-zero vector of the given
length. Each vector gives the coefficients for forming a linear sum
of generator matrices.
</li>
<li>
<h3><a name="zchar">zchar</a></h3>
Purpose: Print the (field) characteristic of a matrix. In the case of a permutation, print 1.
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input matrix</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The characteristic</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: This program is mainly used for consistency checking in
scripts between arguments. However, it also used to determine if an
indicator calculation should be performed (only necessary in
characteristic 2, as otherwise the indicators are available from the
decomposition matrix).
</li>
<li>
<h3><a name="zcheck">zcheck</a></h3>
Purpose: An internal consistency checking program
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The matrix to be checked</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>No catastrophic errors detected</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: This program is not really meant to be used by users. It
is for the detection of corrupted matrices, in particular for the case
where non-zero values have appeared off the ends of rows (which don't
exactly fill a word). Errors are reported on stderr, however, a
non-zero error code is only given for failures such as inability to
read the matrix.
</li>
<li>
<h3><a name="zclean">zclean</a></h3>
Purpose: Clean one set of vectors with another
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Clean vectors</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Vectors to be cleaned</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>0</td><td valign=top>Insufficient memory</td>
</tr>
</table>
Commentary: This can be used as part of finding vector space direct
complements.
</li>
<li>
<h3><a name="zconj">zconj</a></h3>
Purpose: Produce an algebraic conjugate of a matrix. In
the case of a permutation, simply copy.
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input matrix</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Output matrix</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Power of the Frobenius map to be applied</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: This is only useful when the field of the matrix is not
the prime field. All elements in the output will be the corresponding
input elements raised to the power p**n, where p is the field
characteristic, and n is the input value from parameter 3. If the
field of the matrix is the prime field, or the matrix is a
permutation, then the output will be a copy of the input.
</li>
<li>
<h3><a name="zct">zct</a></h3>
Purpose: Count the number of non-zero entries of a matrix
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input matrix</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The number of non-zero entries</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: The purpose of this program is to give the user some idea
of how expensive operations such as multiply will be with this matrix
as the left hand operand. The cost of multiply is roughly proportional
to the number of non-zero entries in the left hand operand. In some
circumstances, when the right hand operand is sparse and the left hand
operand is not, it may make sense to transpose both operands, multiply
in the reverse order and transpose the result. This program also works
on permutations.
</li>
<li>
<h3><a name="zcv">zcv</a></h3>
Purpose: Input from text to binary
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Text input file</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>binary output file</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: This program inputs both matrices and permutations from
text into binary. The textual format is roughly the Birmingham atlas
version 1 format, with the exact formatting rules relaxed to allow
numbers greater than 999999 for the purposes particularly of
permutations. Permutations are not converted to matrices, but remain
in an internal binary map form. If matrices are required, then either
<a href="#zip">zip</a> can be used, or multiplication by a suitable
identity can be performed.
</li>
<li>
<h3><a name="zdiag">zdiag</a></h3>
Purpose: Extract the diagonal of a square matrix
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input matrix</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Output matrix</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: This is a support program for the calculation of
indicators in characteristic 2. It is not expected to be used
otherwise.
</li>
<li>
<h3><a name="zdiff">zdiff</a></h3>
Purpose: This is used in the computation of quadratic forms to check
preservation of the bilinear form by the group elements. It has also
been used as a diagnostic program for looking at differences between
matrices in a human readable form.
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input 1</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Input 2</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The differences, row by row</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: Used in indicator calculations
</li>
<li>
<h3><a name="zdiffd">zdiffd</a></h3>
Purpose: Check that the diagonal of a quadratic form has been
preserved by a group element.
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Matrix</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Field element</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Compares equal</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>Compares unequal</td>
</tr>
</table>
Commentary: Used in indicator calculations to check for preservation
of the diagonal.
</li>
<li>
<h3><a name="zex">zex</a></h3>
Purpose: Explode ordinary matrix
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input matrix</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Output directory</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Submatrix size. This will be rounded up to occupy full
words</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: The directory in which the output is to be placed must
exist. This prograsm will not create it.
</li>
<li>
<h3><a name="zexport">zexport</a></h3>
Purpose: Export binary data to Aachen meataxe
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input matrix</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Output matrix</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: This performs two transformations on the input. The first
reverses the order of small groups of adjacent column entries. The
second then rewrites these groups as polynomials in the field order.
For GF(2), the second transformation is a nop, and the effect is to
take a bit ordering where column 0 is in bit 0 of word 0, and recast
it as bit 7 of byte 0. The general rule is that bit fields packed into
words in a little endian fashion are recast as polynomials packed into
bytes in a bit big endian fashion. The reverse transformation is
<a href="#zimport">zimport</a>.
</li>
<li>
<h3><a name="zfe">zfe</a></h3>
Purpose: Extend field
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input matrix</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Output matrix</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Order of extension field</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: Essentially, each entry is rewritten in a larger bitfield
suitable to contain elements of the extension field. The extension
field order must be a power of the input field order. In the case that
the input is a permutation, the operation reduces to a copy.
Currently, the only field extension available is from GF(2) to GF(4).
If more complicated fields become available, in particular fields with
more than one strict subfield other than the prime field, and where
the inclusion ordering of subfields is not total, then some extra work
will probably be required in this program. The first case in which
this occurs is GF(64) (which is unlikely to be required for quite some
time).
</li>
<li>
<h3><a name="zfln">zfln</a></h3>
Purpose: Find an element of non-zero lowest nullity bounded by the
input parameter
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Stem for creation of output file names</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Depth of search</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Maximum acceptable nullity</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Order of generator 1</td>
</tr>
<tr>
<td valign=top>6-</td><td valign=top>Other generators and orders</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The element, if found, plus the
script to create it</td>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for matrix plus workspace</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>No element of the required
nullity found</td>
</tr>
</table>
Commentary: This program is used analogously to <a
href="#zsums">zsums</a> in the situation where the representation in
question is irreducible but not absolutely irreducible. In this
situation, all nullities will be multiples of the dimension of the
algebra preserving endomorphism ring of the irreducible to itself. By
examining a large number of nullities, and taking the highest common
factor, one can hope to deduce the dimension, and hopefully also find
an element with that dimension. The general situation in which this is
used is either classifying irreducibles of a condensation, or
classifying irreducibles of a condensation subgroup.
</li>
<li>
<h3><a name="zflnf">zflnf</a></h3>
Purpose: An intermediate file based version of <a
href="#zfln">zfln</a>
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Stem for creation of output file names</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Depth of search</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Maximum acceptable nullity</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Directory for temporary files</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Order of generator 1</td>
</tr>
<tr>
<td valign=top>7-</td><td valign=top>Other generators and orders</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The element, if found, plus the
script to create it</td>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for matrix plus workspace</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>No element of the required
nullity found</td>
</tr>
</table>
Commentary: This program is solely for use where zfln would be used if
memory constraints permitted. It is wrapped by <a
href="#find_best_nullityf_with_orders">find_best_nullityf_with_orders</a>
</li>
<li>
<h3><a name="zfn">zfn</a></h3>
Purpose: Filter on nullity
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input file to be filtered</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Filtered result</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>The nullity to be selected</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>First generator</td>
</tr>
<tr>
<td valign=top>5-</td><td valign=top>Further generators</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported
textually by the program</td>
</tr>
</table>
Commentary: This is part of a suite of three programs used when
searching for delta words for tensor condensation. This involves
finding a word with a required non-zero nullity on one representation
and nullity zero on all others. The program takes a list of group
algebra words (as linear sums of the generators, with the identity
also added in) and for each element in the list computes the nullity
of that element in the given representation. If the nullity matches,
the word is output, otherwise it is discarded. Further programs <a
href=#zcfl>zcfl</a> and <a href=#zpfl>zpfl</a> exist to respectively
create the list and print the final results. The programs can be run
in combination via a script <a
href=#filter_element>filter_element</a>.
</li>
<li>
<h3><a name="zfo">zfo</a></h3>
Purpose: Find orbits under a number of permutations
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Output orbit file</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>First input permutation</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Maximum orbit size under generator
1 (the element order will do here)</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Further generators</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported
textually by the program</td>
</tr>
</table>
Commentary: A binary orbit file is produced. This consists of a
standard meataxe binary header (with prime 1), followed by an integer
giving the number of orbits, followed by a number of orbits, each of
which consists of an integer size, followed by the integer point names
in the orbit.
</li>
<li>
<h3><a name="zformat">zformat</a></h3>
Purpose: Identify the meataxe size type of a file
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>file</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The number
of bits in a word for this file (currently either 32 or 64)</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported
textually by the program</td>
</tr>
</table>
Commentary: Identifies the meataxe type for this file
</li>
<li>
<h3><a name="zfr">zfr</a></h3>
Purpose: Retract field
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input matrix</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Output matrix</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Order of retraction field</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: The matrix is treated as being of larger dimension over a
subfield. If the input field is a degree n extension of the output
field, then the number of rows and columns are each multiplied by n.
</li>
<li>
<h3><a name="zid">zid</a></h3>
Purpose: Create identity matrix
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Field order</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Number of rows</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Number of columns</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Output matrix</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: The output is not required to be square. It is simply
guaranteed to be 1 on its main diagonal, and 0 elsewhere. Thus, for
example, the unit vector e0 over GF(3) with 200 columns can be
produced by <a href="#zid">zid</a> 3 1 200 e0.
</li>
<li>
<h3><a name="zimport">zimport</a></h3>
Purpose: Import binary data from Aachen meataxe
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input matrix</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Output matrix</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: This is the inverse of <a href="#zexport">zexport</a>.
</li>
<li>
<h3><a name="zip">zip</a></h3>
Purpose: Input permutation as matrix
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input text file</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Output matrix</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Field order</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: This program inputs permutations directly to matrices. If
binary permutations are required, the program <a href="#zcv">zcv</a>
should be used. The input format is essentially the Aachen format, but
with some of the format restrictions relaxed, in particular to allow
permutations on more than 999999 points. Given that programs such as
<a href="#zmsp">zmsp</a> can deal directly with permutation group
generators, as can <a href="#zad">zad</a> and <a href="#zmu">zmu</a>,
it should rarely be necessary to use this program.
</li>
<li>
<h3><a name="ziv">ziv</a></h3>
Purpose: Invert matrix
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input matrix (or map)</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Output matrix (or map)</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for matrix plus workspace</td>
</tr>
</table>
Commentary: This requires sufficient memory for two full copies of the
input, plus some workspace (approximately another 10%). If this is not
available, the program <a href="#zivf">zivf</a> should be used
instead. Maps are inverted to give maps. Gaussian elimination is used
to invert input matrices. If the input is found to be singular, an
error will be generated. Obviously, the input must be square.
</li>
<li>
<h3><a name="zivf">zivf</a></h3>
Purpose: Invert a matrix (or map) using intermediate files
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input matrix (or map)</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Output matrix (or map)</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Temporary (worksapce) directory</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: Maps are inverted to give maps. Gaussian elimination is
used to invert input matrices. Intermediate files are used to
accommodate input which is larger than half the available memory. If
the input is found to be singular, an error will be generated.
Obviously, the input must be square. The temporary workspace directory
must exist, this program will not create it.
</li>
<li>
<h3><a name="zjoin">zjoin</a></h3>
Purpose: Form the non-direct sum V + W from two matrices V and W
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>First matrix</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Second matrix</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Output matrix</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: Either of the two parameters may be a map, but not both.
There are two potential uses for this program. In the first, one can
calculate the intersection of two spaces V and W, by forming the sum
using <a href="#zjoin">zjoin</a>, and then computing null vectors of
the result matrix. Cutting any resulting null vector to the first n
columns, where n = dim V, provides a linear combination of vectors in
V lying in V intersect W. The second is to unite subspaces in a case
where one would prefer to create subspaces in a larger dimensional
representation because the group generators are more convenient, eg as
permutations or tensor products.
</li>
<li>
<h3><a name="zlp">zlp</a></h3>
Purpose: Line permute
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input vector</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Output set of vectors</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Generator 2</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Permutation for generator 1</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Permutation for generator 2</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The number of points in the orbit</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for vectors plus workspace</td>
</tr>
</table>
Commentary: This is similar to <a href="#zvp">zvp</a>, except that
lines rather than points are permuted. One could also regard it as the
dimension 1 case of subspace permute, although that program is not yet
available.
</li>
<li>
<h3><a name="zlpf">zlpf</a></h3>
Purpose: Line permute using intermediate file
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Directory for temporary files</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Input vector</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Output set of vectors</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Generator 2</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Permutation for generator 1</td>
</tr>
<tr>
<td valign=top>7</td><td valign=top>Permutation for generator 2</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The number of points in the orbit</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory</td>
</tr>
</table>
Commentary: This is similar to <a href="#zlp">zlp</a>, but without
constraining the number of vectors to the total available memory.
</li>
<li>
<h3><a name="zlv">zlv</a></h3>
Purpose: Lift vectors from a quotient space
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The subspace vectors</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>The vectors to be lifted</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>The pre-images</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: This process performs an inverse for <a
href="#zproj">zproj</a>, in that it produces vectors in the original
space which project to the given vectors, by widening the given
vectors and inserting zeroes at the pivot columns.
</li>
<li>
<h3><a name="zmsb">zmsb</a></h3>
Purpose: Compute a standard basis of vectors from a single seed
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The input vector</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>The output basis</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Generator 1 (matrix or permutation)</td>
</tr>
<tr>
<td valign=top>4-</td><td valign=top>Further generators (matrix or permutation)</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The basis size</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for two matrices plus workspace</td>
</tr>
</table>
Commentary: This produces a basis consisting entirely of elements in
the same G orbit, and ordered as follows. The first element is the
seed. At any stage we apply a generator to all elements it has not
been applied to yet, and add these one at a time, in order, to the
basis if they are linearly independent. We then switch to the next
generator and repeat. The process terminates when either a proper
subspace has been found, in which case the program exits with code 1,
or the entire space has been generated. Any generator can be a
permutation, however, it is unlikely that all will be, since a
permutation module cannot be irreducible.
</li>
<li>
<h3><a name="zmsbf">zmsbf</a></h3>
Purpose: Compute a standard basis of vectors from a single seed
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The input vector</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>The output basis</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Temporary file directory</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Generator 1 (matrix or permutation)</td>
</tr>
<tr>
<td valign=top>5-</td><td valign=top>Further generators (matrix or permutation)</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The basis size</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for two matrices plus workspace</td>
</tr>
</table>
Commentary: This program implements the same algorithm as <a
href="#zmsb">zmsb</a>, but uses intermediate files to cope with lack of
main memory. fseek and ftell are used to position within the file used
to record an echelised basis (need in order to determine whether a new
vector is linearly independent). In the case of files exceeding 2Gb,
fseeko64 and ftello64 are used. Unfortunately, these require long long
on 32 bits systems, which is not ANSI. However, the alternative is to
be unable to perform <a href="#zmsb">zmsb</a> at all. If long files are
required, then they have to be supported in the kernel and C library,
which will be a problem on some older linux systems. The exit codes
are as for <a href="#zmsb">zmsb</a>. The temporary workspace directory
must exist, this program will not create it.
</li>
<li>
<h3><a name="zmsp">zmsp</a></h3>
Purpose: Produce a minimal subspace stable under multiple generators
containing a given vector.
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The input vector</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>The subspace</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>4- *</td><td valign=top>Remaining generators</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The
subspace dimension, or if memory is exhausted, the number of rows
produced at that stage</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for subspace plus workspace</td>
</tr>
</table>
Commentary: This program generates a subspace by applying each of the
generators in turn to the vectors already generated but to which this
generator has not yet been applied, until either no new linearly
independent vectors are produced, or the program runs out of memory.
Any generator may be a map, but the seed may not. The subspace
produced is in fully echelised form, as defined earlier in this
documentation.
</li>
<li>
<h3><a name="zmspf">zmspf</a></h3>
Purpose: Produce a minimal subspace stable under multiple generators
containing a given vector, and using intermediate files.
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The input vector</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>The subspace</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Directory for temporary files</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>5- *</td><td valign=top>Remaining generators</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The
subspace dimension</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: This is a version of <a href="#zmsp">zmsp</a> where
intermediate files can be used. This is especially important either
when the meataxe is being used on groups which are not two generator,
or when it is being used on condensations (which frequently require
more than two generators), and subspaces larger than the available
memory are to be produced.
</li>
<li>
<h3><a name="zmvp">zmvp</a></h3>
Purpose: Vector permute with multiple generators
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input vector</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Output set of vectors</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>4- *</td><td valign=top>Remaining generators</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The number of points in the orbit</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for vectors plus workspace</td>
</tr>
</table>
Commentary: This is very similar to <a href="#zvp">zvp</a>
but taking multiple generators.
</li>
<li>
<h3><a name="zmu">zmu</a></h3>
Purpose: Multiply two matrices (or maps)
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>First matrix (or map)</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Second matrix (or map)</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Result matrix (or map)</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: Either operand may be a map. If both are, then the result
will be as well. Multiplication can be quite sensitive to the amount
of memory supplied, and furthermore, if one of the operands fits in
the file buffer cache, then increasing the amount of memory may not
necessarily improve the speed (indeed, it can make it worse). The
correct amount of memory to supply depends both on the buffer cache
size, and the CPU cache size, in a way that is not yet fully
understood. It is not necessary to provide memory to contain both
operands.
</li>
<li>
<h3><a name="znoc">znoc</a></h3>
Purpose: Print the number of columns of a matrix or map
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The matrix or map</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The number of columns</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: This program, and the other similar ones <a
href="#znor">znor</a>, <a href="#zchar">zchar</a> and zprime, are
mainly for use in scripts where new names are to be invented
automatically, and are normally derived from the dimensions. Also,
they are used to perform some compatibility testing between various
parameters to scripts.
</li>
<li>
<h3><a name="znor">znor</a></h3>
Purpose: Print the number of rows of a matrix or map
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The matrix or map</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The number of rows</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: As for <a href="#znoc">znoc</a>
</li>
<li>
<h3><a name="zns">zns</a></h3>
Purpose: Compute the nullspace of a matrix
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The matrix</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>The nullspace</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The nullity</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for matrix plus workspace</td>
</tr>
</table>
Commentary: This is an in store nullspace computation. The space
required is roughly twice the input matrix size plus about 10%.
Greased Gaussian elimination is applied to the input matrix, and the
corresponding row operations are also applied to a matrix starting as
the identity. Null vectors are found in this second matrix
corresponding to rows in the first matrix which become zero. Null
vectors are produced in the order of the rows to which they
correspond. If insufficient memory is available for in store nullity,
then <a href="#znsf">znsf</a> should be used instead. It is not
possible to compute the nullspace of a map.
</li>
<li>
<h3><a name="znsf">znsf</a></h3>
Purpose: Compute the nullspace of a matrix, using intermediate files
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input matrix</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Output nullspace</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>A directory for temporary files</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The nullity</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for matrix plus workspace</td>
</tr>
</table>
Commentary: This program is essentially the same as <a
href="#zns">zns</a>, except that it uses intermediate files to extend
the range of input size it can manage. An initial number of vectors is
read and echelised using standard Gaussian elimination, and then these
are used to clean the remainder of the input, copying the result to a
new temporary file. The process than restarts with that temporary file
as input. The record of operations is similarly kept in corresponding
temporary files. The temporary workspace directory must exist, this
program will not create it.
</li>
<li>
<h3><a name="zntco">zntco</a></h3>
Purpose: Tensor condense (new algorithm)
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Number of irreducibles of
condensation subgroup</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Multiplicities of tensor parameter
1</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Multiplicities of tensor parameter
2</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>File of irreducible dimensions for
condensation subgroup</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>File of endomorphism ring
dimensions for condensation subgroup</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Tensor parameter 1</td>
</tr>
<tr>
<td valign=top>7</td><td valign=top>Tensor parameter 2</td>
</tr>
<tr>
<td valign=top>8</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>9</td><td valign=top>Endomorphism ring basis (Q) for
first irreducible</td>
</tr>
<tr>
<td valign=top>10</td><td valign=top>Projection matrix (P) for first
irreducible</td>
</tr>
<tr>
<td valign=top>11-</td><td valign=top>Further bases and projections</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient workspace</td>
</tr>
</table>
<p>
Commentary: This is a revised implementation of the direct tensor
condensation algorithm, as described in Lux and Wiegelmann -
Condensing Tensor Product Modules, to which the user is referred for a
fuller description of condensation in general and tensor condensation
in particular. The algorithm produces the result in a different order
from that described in the paper, and achieves an average factor 25
speed up as a result. The result is nevertheless identical to that
produced by <a href="ztco">ztco</a> given the same input.
</p>
<p>
It seems reasonable at this point to include a summary of the steps
required to do tensor condensation. Some of these are in common with
other forms of condensation such as permutation condensation,
nevertheless they will be documented here anyway. The prerequisites
are generators for the group G under consideration, a chosen p'
subgroup H over which condensation is to be performed, and a recipe
for obtaining generators for H from those of G
</p>
<p>
These recipes can typically be obtained either from the QMW Atlas, or
from the GAP package atlasrep using the table of marks facilities (and
typically both are required).
</p>
<p>
Stage 1 is to find the full set of irreducibles of H. For each such
irreducible I, with dual J, we require the sum over the elements h of
H of I(h) tensor J(h). A single script (often called e_script) can do
this for all the irreducibles. From these sums we compute per
irreducible left and right multiplier matrices Q and P. The script <a
href="#qp">qp</a> does precisely this.
</p>
<p>
We now need to construct symmetry bases for all representations we
wish to use within the condensation process. These can be built using
either delta words (for which the programs zranks, and the scripts
find_element and check_elements can be used). It can be hard to find
delta words and there is some evidence that they don't always work
(although the exact reason for this are unclear). Alternatively gamma
operators can be used. These also have their own downsides, as for
large representations they can be very slow. However, you do only need
to construct one symmetry basis per representation, no matter how many
times that representation participates in condensations. The scripts
<a href="#sym_basis">sym_basis</a> (for gamma operators) and
<a href="#sym_basis_delta">sym_basis_delta</a> (for delta words), 
can then be used to construct the required symmetry bases
</p>
<p>
Once symmetry bases are available, we need to conjugate the original
group generators into these bases. Typically the condensation algebra
is not generated by just the condensed form of the group generators.
Often up to four generators can be required, eg A, B, AB, BA.
</p>
<p>
Finally we use zntco as documented above to produce the condensation
for each generator in turn, and then analyse the result using
split_all_cond.
</p>
</li>
<li>
<h3><a name="ztcocon">ztcocon</a></h3>
Purpose: Tensor condense continue
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Number of irreducibles of
condensation subgroup</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Multiplicities of tensor parameter
1</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Multiplicities of tensor parameter
2</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>File of irreducible dimensions for
condensation subgroup</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>File of endomorphism ring
dimensions for condensation subgroup</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Tensor parameter 1</td>
</tr>
<tr>
<td valign=top>7</td><td valign=top>Tensor parameter 2</td>
</tr>
<tr>
<td valign=top>8</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>9</td><td valign=top>Input</td>
</tr>
<tr>
<td valign=top>10</td><td valign=top>Loop number</td>
</tr>
<tr>
<td valign=top>11</td><td valign=top>Loop start point</td>
</tr>
<tr>
<td valign=top>12</td><td valign=top>Endomorphism ring basis (Q) for
first irreducible</td>
</tr>
<tr>
<td valign=top>13</td><td valign=top>Projection matrix (P) for first
irreducible</td>
</tr>
<tr>
<td valign=top>14-</td><td valign=top>Further bases and projections</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient workspace</td>
</tr>
</table>
Commentary: This program is to carry on where a preceding tenosr
condense has failed due to machine crash. It takes three extra
parameters not used by <a href=#ztco>ztco</a>, to specify the
condensed tensor so far, and at what point in the algorithm to
continue. The algorithm has an outer loop (parameter 0) controlling
which irreducible of the condensation subgroup is being dealt with, a
first inner loop (parameter 1) over the multiplicity of this
irreducible in the left tensor, and a second inner loop (parameter 2)
over the multiplicity of the given irreducible in the right tensor. A
continuation point can be specified for one of these three parameters.
The loop number takes values 0, 1 or 2 according to which parameter is
to be given. The loop start point then indicates the starting value of
the parameter in question. If an inner loop initial value is
specified, then all containing loops start at their maximum value.
See Lux and Wiegelmann - Condensing Tensor Product Modules for a
fuller description of condensation in general and tensor condensation
in particular.
</li>
<li>
<h3><a name="zpfl">zpfl</a></h3>
Purpose: Print filter list
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Filter list file</td>
</tr>
<tr>
<td valign=top>2-</td><td valign=top>Generators</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>Algebra
elements given by the filter list</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported
textually by the program</td>
</tr>
</table>
Commentary: This is part of a suite of three programs used when
searching for delta words for tensor condensation. The input is the
list of all elements satisfying the nullity conditions. The output is
a list of group algebra words, one per row of the input, where the
coefficients are the entries in the individual input rows.
</li>
<li>
<h3><a name="zpco">zpco</a></h3>
Purpose: Permutation condense relative to an orbit file
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Orbit file</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Permutation to be condensed</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Condensed matrix</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Field order over which
condensation to be done</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported
textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for one row of
matrix workspace</td>
</tr>
</table>
<p>
Commentary: Condense a permutation relative to a set of orbits, as
described in Cooperman, Hiss, Lux and Mueller "The Brauer Tree of the
Principal 19-Block of the Sporadic Simple Thompson Group". It is worth
noting that the matrices produced by condensation are fairly row
sparse, since the number of non-zero entries in any row can be at most
the orbit size of the orbit indexing this row.
</p>
<p>
Permutation condensation starts in a fashion similar to tensor
condenstion but is considerably simpler. We obtain generators of the
condensation subgroup H, and then use <a href="#zfo">zfo</a> to find
the orbits of these on the original set. Finally we use zpco to
produce the condensed form.
</p>
</li>
<li>
<h3><a name="zpcv">zpcv</a></h3>
Purpose: Lift vectors from a condensed permutation representation
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The permutation orbit set</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>The vectors to be lifted</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>The pre-images</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: This process performs a partial inverse for the
condensation process, in that it produces vectors in the original
space which lie in the fixed space of the condensation subgroup. It
does this by expanding each non-zero entry in an input vector to a set
of values equal to this entry, one at each orbit point in the orbit
represented by this basis element in condensed space.
</li>
<li>
<h3><a name="zpofp">zpofp</a></h3>
Purpose: Find fixed points in an orbit
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The permutation orbit set</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>The orbit number (zero based)</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>The output file</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>First permutation input</td>
</tr>
<tr>
<td valign=top>5-</td><td valign=top>Further permutations</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The number
of fixed points</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: Generate a list, as a map file, of the fixed points in a
given orbit under the set of permutations.
</li>
<li>
<h3><a name="zpr">zpr</a></h3>
Purpose: Print a matrix or map
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The input</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The printed form of the matrix
or map</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for one row of matrix workspace</td>
</tr>
</table>
Commentary: This is the inverse of <a href="#zcv">zcv</a>. It can be
used as an alternative import/export mechanbism between this meataxe
and the Aachen meataxe.
</li>
<li>
<h3><a name="zprime">zprime</a></h3>
Purpose: Print the field order of a matrix or map
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The matrix or map</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The field order</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: This program is slightly misnamed, but I don't feel
inclined to change it. For a map it prints 1. It's mainly used in
conjunction with <a href="#znor">znor</a> and <a href="#znoc">znoc</a>
by scripts.
</li>
<li>
<h3><a name="zpro">zpro</a></h3>
Purpose: Print an orbit file
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The input</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The
printed form of the orbit</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for one row of matrix workspace</td>
</tr>
</table>
Commentary: Give a textual rendition of an orbit file. For a
description of an orbit file, see <a href="#zfo">zfo</a>.
</li>
<li>
<h3><a name="zproj">zproj</a></h3>
Purpose: Project into quotient space
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The subspace</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>The vectors to be projected (may be a map)</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>The result</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: This is used to project vectors into a quotient space. It
can be used in the context eg when one has several vectors with which
one might spin, and a subspace resulting from one of them. One can
then project the remaining vectors into the quotient, and possibly
spin again without the extra cost of a nullspace operation. This
program does not reduce its output to a basis. <a
href="#zbase">zbase</a> should be used for that. A typical use
sequence use sequence might be :- produce nullspace, find subspace
with one vector, produce sub and quotient space representations,
analyse subspace, project nullspace into quotient, reduce to a basis,
spin again with a vector from the linear span of this basis.
</li>
<li>
<h3><a name="zps">zps</a></h3>
Purpose: Compute permutation representation
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Set of vectors closed under the group action</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Image of above set under group element</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Action of the group element as a permutation</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: Produce a permutation representation from a set of vectors
and a permuted set of the same, in a very naive way. Note that <a
href="#zvp">zvp</a> already produces the permutations on a pair of
generators, and has a somewhat better algorithm.
</li>
<li>
<h3><a name="zqf">zqf</a></h3>
Purpose: Quadratic form  extraction program
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input matrix (must be square)</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Output matrix</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: This is a support program for the calculation of
indicators in characteristic 2. It extracts the above diagonal
triangle of a matrix, setting the diagonal and below to zero. The
input is expected to be a symmetric matrix, giving an alternating
non-degenerate bilinear form on the space, although this program will
not fail if this conditional is not met.
</li>
<li>
<h3><a name="zqs">zqs</a></h3>
Purpose: Produce quotient representation
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The subspace vectors</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>The group (algebra) element (may be a map)</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>The quotient representation</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: This program uses a basis for the quotient space
consisting of those unit vectors which do not appear as pivots in the
subspace. It is assumed that the subspace is echelised, such that each
row has a unique pivot, its left most non-zero entry, set to 1, and
the only non-zero entry in its column. Rows in the group algebra
element corresponding to pivots are ignored, and the remaining rows
are cleaned with the subspace, and then contracted to remove all pivot
rows. The program is linear in the row length, and linear in each of
the subspace and quotient space size.
</li>
<li>
<h3><a name="zrand">zrand</a></h3>
Purpose: Generate a random matrix
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Field order</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Number of rows</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Number of columns</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Output file</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory</td>
</tr>
</table>
Commentary: This program is intended for use in performance testing.
It has little mathematical significance
</li>
<li>
<h3><a name="zranks">zranks</a></h3>
Purpose: Compute the nullities of a sequence of group algebra elements
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Stem for creation of output file names</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Depth of search</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Maximum acceptable nullity</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Order of generator 1</td>
</tr>
<tr>
<td valign=top>6-</td><td valign=top>Other generators and orders</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The elements names, the scripts
to construct them, and the nullities</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for matrix plus workspace</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>No element of the required
nullity found</td>
</tr>
</table>
Commentary: This is one of a number of similar programs to support
either the finding of elements of low nullity to split
representations, or elements of nullity one to seed standard base
calculations, or elements which have low nullity on a particular set
of irreducibles, and nullity zero on all known others. Sometimes when
trying to split, it turns out that all the standard simple group
algebra elements (from the f scripts, see later) behave
pathologically, either by having nullity zero or very large on the
representation under consideration. Under these circumstances a more
exhaustive search for an element of low non-zero nullity is warranted.
The standard base application is simply a way of getting a basis
independent module generator (ie depending only on a group algebra
element as a formula in its generators), guaranteeing that if two
instances of a representation are isomorphic, then the two module
generators can be made to correspond under such an isomorphism. The
final application is to produce an element suitable for splitting a
representation, often containing a new unknown irreducible, in a way
that doesn't produce a very large number of potential submodule
generators. Such methods have for example been applied extensively in
the construction of new irreducibles for Co1. The program stops when a
word of length exceeding the specified depth would be required to
produce more elements.
</li>
<li>
<h3><a name="zre">zre</a></h3>
Purpose: Another export program
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input matrix</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Output matrix</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: This is another conversion program, specific to the
modified Aachen meataxe that was used to perform the first monster
element multiplications. The format used there was somewhat curious,
having the bit reversal mentioned in <a href="#zexport">zexport</a>,
and a big-endian header. In general, users should not need this
program.
</li>
<li>
<h3><a name="zrestrict">zrestrict</a></h3>
Purpose: Restrict a matrix (or map) to a subfield
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input matrix (or map)</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Output matrix</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Subfield order</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>Failed to restrict (ie an entry not living in the
desired subfield was found)</td>
</tr>
</table>
Commentary: This is intended to rewite a matrix over a smaller
subfield, given that all its entries lie in that field. In the case of
a map, it reduces to a copy. It is generally expected that this
program will be used from a script, in conjunction with a program that
finds a basis such that the group generators have entries lying
entirely in the subfield.
</li>
<li>
<h3><a name="zrn">zrn</a></h3>
Purpose: Compute the rank of a matrix (or map)
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The matrix (or map)</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The rank</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for matrix plus workspace</td>
</tr>
</table>
Commentary: This computes the rank of a matrix in store, using about
10% more memory than that required to hold the matrix. If insufficient
memory is required, the program <a href="#zrnf">zrnf</a> should be
used. The program uses greased Gaussian elimination, and is linear in
the numbers of columns and quadratic in the number of rows (and
therefore cubic in the dimension for square matrices). In the case of
a map, the rank is that of the corresponding matrix, and is equal to
the number of distinct images under the map.
</li>
<li>
<h3><a name="zrnf">zrnf</a></h3>
Purpose: Compute the rank of a matrix (or map) using intermediate files.
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The matrix (or map)</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>A temporary directory for workspace files</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The rank</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: This program can be used when there is insufficient memory
to run <a href="#zrn">zrn</a>. Its algorithm is essentially the same
as <a href="#znsf">znsf</a>, except that there is no need to keep
track of how the input has been echelised. The temporary workspace
directory must exist, this program will not create it.
</li>
<li>
<h3><a name="zrranks">zrranks</a></h3>
Purpose: A version of <a href="#zranks">zranks</a> over a restricted
field
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Stem for creation of output file names</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Depth of search</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Maximum acceptable nullity</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Subfield order</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Order of generator 1</td>
</tr>
<tr>
<td valign=top>7-</td><td valign=top>Other generators and orders</td>
</tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The elements names, the scripts
to construct them, and the nullities</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for matrix plus workspace</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>No element of the required
nullity found</td>
</tr>
</table>
Commentary: Essentially the same as <a href="#zranks">zranks</a>,
except that the coefficients in the group algebra elements are
restricted to be in a subfield.
</li>
<li>
<h3><a name="zrsums">zrsums</a></h3>
Purpose: A field restricted version of <a href="#zsums">zsums</a>
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Stem for creation of output file names</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Depth of search</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Maximum acceptable nullity</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Subfield order</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Order of generator 1</td>
</tr>
<tr>
<td valign=top>7-</td><td valign=top>Other generators and orders</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The element, if found, plus the
script to create it</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for matrix plus workspace</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>No element of the required
nullity found</td>
</tr>
</table>
Commentary: This program is mainly used to find an element of nullity
one where the coefficients of the group elements all lie in a
subfield. If the representation itself exists in such a subfield, then
the element produced by <a href="#zrsums">zrsums</a> will seed a
standard base. Hence, performing the standard base using this element
over the actual field, will produce a representation all of whose
entries lie in the subfield, if such a representation exists. The
discovery of an element of nullity one over the subfield does not
guarantee that the representation exists in the subfield, but it does
guarantee to produce it if it exists.
</li>
<li>
<h3><a name="zrsumsf">zrsumsf</a></h3>
Purpose: A field restricted version of <a href="#zsumsf">zsumsf</a>
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Stem for creation of output file names</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Depth of search</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Maximum acceptable nullity</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Subfield order</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Temporary directory</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>7</td><td valign=top>Order of generator 1</td>
</tr>
<tr>
<td valign=top>8-</td><td valign=top>Other generators and orders</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The element, if found, plus the
script to create it</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for matrix plus workspace</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>No element of the required
nullity found</td>
</tr>
</table>
Commentary: This program is mainly used to find an element of nullity
one where the coefficients of the group elements all lie in a
subfield. If the representation itself exists in such a subfield, then
the element produced by <a href="#zrsumsf">zrsumsf</a> will seed a
standard base. Hence, performing the standard base using this element
over the actual field, will produce a representation all of whose
entries lie in the subfield, if such a representation exists. The
discovery of an element of nullity one over the subfield does not
guarantee that the representation exists in the subfield, but it does
guarantee to produce it if it exists.
</li>
<li>
<h3><a name="zsad">zsad</a></h3>
Purpose: Scaled addition. The scalar applies to parameter 1
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input matrix 1</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Input matrix 2</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Output matrix</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>The scalar</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: 
</li>
<li>
<h3><a name="zscript">zscript</a></h3>
Purpose: Evaluate an element of the group algebra
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Filename stem for temporary files</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>The script describing the word to be computed</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Group generator 1</td>
</tr>
<tr>
<td valign=top>5-</td><td valign=top>other generators</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for matrix plus workspace</td>
</tr>
</table>
Commentary: The main purpose of this program is in the calculation of
indicators, where a script producing the element whose nullspace seeds
the standard basis is known, and needs to be evaluated over the dual
space generators. Scripts are limited to sums of scaled words in the
generators, with the additional possibility that the first addend may
be I. Scaled words consist of an integer followed by a word in the
letters A through H, which correspond to generators 1 to 8. For example,
I+A+BB, I+2A+3C. Some generators may be permutations, although not all
may be.
</li>
<li>
<h3><a name="zsel">zsel</a></h3>
Purpose: Extract a row from a matrix
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The matrix</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>The output row</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>The row number</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: This is mainly used as a support program to select vectors
from a set produced by <a href="#zspan">zspan</a>, in order to seed
subspaces.
</li>
<li>
<h3><a name="zsid">zsid</a></h3>
Purpose: Scaled identity matrix
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Field order</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Number of rows</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Number of columns</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Scalar</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Output matrix</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: The output is not required to be square. It is simply
guaranteed to be &lt;scalar&gt; on its main diagonal, and 0 elsewhere.
</li>
<li>
<h3><a name="zsign">zsign</a></h3>
Purpose: Find the orthogonal group sign with respect to a quadratic
form and its associated bilinear form
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The quadratic form</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>The bilinear form</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Space has sign + (ie it has a
maximum possible size totally singular subspace)</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>Space has sign -</td>
</tr>
</table>
Commentary: Spaces of odd dimension are regarded as having sign +. In
the case of odd characteristic, the same matrix can be supplied as the
quadratic and bilinear form, as we are not interested in the exact
values, merely in zero versus not zero. This program is cubic in
complexity, and is somewhat slower than others in the suite of a
similar complexity, and so should be used sparingly.
</li>
<li>
<h3><a name="zsignf">zsignf</a></h3>
Purpose: Find the orthogonal group sign with respect to a quadratic
form and its associated bilinear form
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The quadratic form</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>The bilinear form</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>A directory in which to create
temporary files</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Space has sign + (ie it has a
maximum possible size totally singular subspace)</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>Space has sign -</td>
</tr>
</table>
Commentary: Spaces of odd dimension are regarded as having sign +. In
the case of odd characteristic, the same matrix can be supplied as the
quadratic and bilinear form, as we are not interested in the exact
values, merely in zero versus not zero. This program is cubic in
complexity, and is somewhat slower than others in the suite of a
similar complexity, and so should be used sparingly. This version uses
an intermediate file to contain the initial identity matrix which is
gradually reduced to the smallest possible complement of a totally
singular subspace inside its space of perpendicular vectors. It needs
very little memory, but is slower than the in store version <a
href="zsign">zsign</a> due to the file access.
</li>
<li>
<h3><a name="zsing">zsing</a></h3>
Purpose: Find a totally singular vector with respect to a quadratic
form
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The space within which to search</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>The quadratic form</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>The output</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>No vector found, space is definite</td>
</tr>
</table>
Commentary: This program is mainly used, if at all, in the computation
of orthogonal group signs
</li>
<li>
<h3><a name="zsize">zsize</a></h3>
Purpose: Report the meataxe word size
<table>
<thead>
<td valign=top>Parameters: None</td>
</thead>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The number
of bits in a word (currently either 32 or 64)</td>
</tr>
</table>
<table>
<thead>Return codes: 0</thead>
</table>
Commentary: Just a means to identify the meataxe type that is installed
</li>
<li>
<h3><a name="zskcu">zskcu</a></h3>
Purpose: Skew cube
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for matrix plus workspace</td>
</tr>
</table>
Commentary: The action of the matrix on the exterior third power is
computed, essentially by computing 3x3 determinants. The input must
have degree at least three.
</li>
<li>
<h3><a name="zskfi">zskfi</a></h3>
Purpose: Skew fifth
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for matrix plus workspace</td>
</tr>
</table>
Commentary: The action of the matrix on the exterior fifth power is
computed, essentially by computing 5x5 determinants. The input must
have degree at least five.
</li>
<li>
<h3><a name="zskfo">zskfo</a></h3>
Purpose: Skew fourth
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for matrix plus workspace</td>
</tr>
</table>
Commentary: The action of the matrix on the exterior fourth power is
computed, essentially by computing 4x4 determinants. The input must
have degree at least four.
</li>
<li>
<h3><a name="zskse">zskse</a></h3>
Purpose: Skew seventh
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for matrix plus workspace</td>
</tr>
</table>
Commentary: The action of the matrix on the exterior seventh power is
computed, essentially by computing 7x7 determinants. The input must
have degree at least seven.
</li>
<li>
<h3><a name="zsksi">zsksi</a></h3>
Purpose: Skew sixth
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for matrix plus workspace</td>
</tr>
</table>
Commentary: The action of the matrix on the exterior sixth power is
computed, essentially by computing 6x6 determinants. The input must
have degree at least six.
</li>
<li>
<h3><a name="zsksq">zsksq</a></h3>
Purpose: Skew square
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for matrix plus workspace</td>
</tr>
</table>
Commentary: The action of the matrix on the exterior square is
computed, essentially by computing 2x2 determinants. The input must
have degree at least two.
</li>
<li>
<h3><a name="zsl">zsl</a></h3>
Purpose: Meataxe slace for exploded operations
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The name of the slave vector</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: This is the slave for the exploded meataxe operations. Its
name should be a single unique word (to distinguish it from other
slaves). It runs until stopped, consuming requests from the commands
file lying in the directory in which it is started. The requests
currently handled include ad, mu and tr, although onl;y mu and ad have
been exercised (by emu). It uses the same locking protocol as emu.
</li>
<li>
<h3><a name="zspan">zspan</a></h3>
Purpose: Produce the projective span of a set of vectors
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input set of vectors</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Output set of vectors</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Number of input vectors to consider</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: This program produces one vector per line in the space
spanned by the input vectors (assuming the input vectors are linearly
independent). This is all that is required for the purposes of being
able to spin with all possible null vectors of a group algebra
element, eg for use within the Norton irreducibility test.
</li>
<li>
<h3><a name="zss">zss</a></h3>
Purpose: Produce subspace representation
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The vectors of the subspace</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>The image of the subspace under the element whose
representation is to be produced</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Output representation</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: This program assumes the the subspace supplied in
parameter 1 is in fully echelised form, and uses this information to
create the matrix transforming this into parameter 2. The algorithm is
quadratic in the number of rows of parameters 1 & 2. It will not
detect faulty input, eg parameter 1 not echelised, parameter 2 not an
image of parameter 1 etc.
</li>
<li>
<h3><a name="zsums">zsums</a></h3>
Purpose: Generate an element of non-zero nullity bounded by the input
parameter
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Stem for creation of output file names</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Depth of search</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Maximum acceptable nullity</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Order of generator 1</td>
</tr>
<tr>
<td valign=top>6-</td><td valign=top>Other generators and orders</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The element, if found, plus the
script to create it</td>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for matrix plus workspace</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>No element of the required
nullity found</td>
</tr>
</table>
Commentary: This program is used either to search for module
generators in the standard base process, or for reasonably low nullity
elements where the standard set of scripts has failed. The group
algebra elements are searched in a standard order, given by the
following recipe. Firstly we produce an ordering on words in the group
generators. This ordering is lexical in the generators, but omits any
element which can be proved to be already in the sequence simply by
knowing the element orders. Thus, for example, if A and B have orders
2 and 3, the sequence will be A, B, AB, BA, BB, ABA, ABB, BAB, BBA,
ABAB etc. For the purposes for which this program is intended, it is
not useful to know the order of the product AB, since it generally
terminates long before that knowledge could be applied. Having
acquired this order, elements are formed by adding all non-zero
multiples of the "current word" to all previously generated elements,
in ascending order of field element (represented as a positive
integer), starting with the element I. Thus in the above example over
GF(2) (which applies eg to Co1), the elements are I, I+A, I+B, I+A+B,
I+AB, I+A+AB, I+B+AB, I+A+B+AB etc. The program computes the rank of
any element having three or more summands (elements with two summands
give the dimension of some eigenspace of the corresponnding group
element, which is generally not useful). The program stops when a
suitable element is found, or when a word of length exceeding the
specified depth would be required to produce more elements. This
standard ordering of group algebra elements ensures that if <a
href="#zsums">zsums</a> is used in the computation of the standard
base of a potentially unknown irreducible, then if it is already
known, it will use the same group algebra element and therefore match.
This highlights two distinct uses of the standard base mechanism. The
first is to classify irreducibles, and the second is to produce
suitable non-degnerate alternating bilinear forms in the computation
of indicators.
</li>
<li>
<h3><a name="zsumsf">zsumsf</a></h3>
Purpose: A version of <a href="#zsums">zsums</a> using intermediate
files.
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Stem for creation of output file names</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Depth of search</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Maximum acceptable nullity</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Temporary workspace directory</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Group generator 1</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Order of generator 1</td>
</tr>
<tr>
<td valign=top>7</td><td valign=top>Group generator 2</td>
</tr>
<tr>
<td valign=top>8</td><td valign=top>Order of generator 2</td>
</tr>
<tr>
<td valign=top>9-</td><td valign=top>Other generators and orders</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The element, if found, plus the
script to create it</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>No element of the required
nullity found</td>
</tr>
</table>
Commentary: See <a href="#zsums">zsums</a>. The temporary files are
used to support internal use of <a href="#zrnf">zrnf</a> when
computing ranks. The other operations (add, multiply) are not space
constrained, and so do not need the use of intermediate files. The
temporary workspace directory must exist, this program will not create
it.
</li>
<li>
<h3><a name="zsv">zsv</a></h3>
Purpose: Compute Schreier and back vectors from a set of permutations
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Orbit start pint (1 based)</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Output Schreier vector</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Output back vector</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>5-</td><td valign=top>Other generators</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory</td>
</tr>
</table>
Commentary: The Schreier and back vector are produced in map form,
using a standard algorithm, and can be printed using zpr. The chosen
point will appear as maximum word in such a print.
</li>
<li>
<h3><a name="zsymb">zsymb</a></h3>
Purpose: Compute a symmetry basis for a particular irreducible
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The expected number of copies of
the irreducible</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>The size of the irreducible</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Input vectors</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Output vectors</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Temporary workspace directory</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>7-</td><td valign=top>Other generators</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The number
of output vectors</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory</td>
</tr>
</table>
Commentary: This computes the portion of a symmetry basis
corresponding to a particular irreducible. The input vectors are the
output of a gamma script or the nullspace of a delta word. The number
of spaces predicts how many copies of the irreducible should be
produced, and the size says how big each will be. The program is
generally used via one of the symmetry basis scripts <a
href="#sym_basis">sym_basis</a> or <a
href="#sym_basis_delta">sym_basis_delta</a>.
</li>
<li>
<h3><a name="zsymsq">zsymsq</a></h3>
Purpose: Compute symmetric square
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input matrix</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Output matrix</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for matrix plus workspace</td>
</tr>
</table>
Commentary: This computes the full symmetric square. In characteristic
2, it therefore contains a copy of the skew square, and a factor
isomorphic to the input under the Frobenius square map. In other
characteristics, it is a direct complement to the skew square.
</li>
<li>
<h3><a name="ztco">ztco</a></h3>
Purpose: Tensor condense
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Number of irreducibles of
condensation subgroup</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Multiplicities of tensor parameter
1</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Multiplicities of tensor parameter
2</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>File of irreducible dimensions for
condensation subgroup</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>File of endomorphism ring
dimensions for condensation subgroup</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Tensor parameter 1</td>
</tr>
<tr>
<td valign=top>7</td><td valign=top>Tensor parameter 2</td>
</tr>
<tr>
<td valign=top>8</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>9</td><td valign=top>Endomorphism ring basis (Q) for
first irreducible</td>
</tr>
<tr>
<td valign=top>10</td><td valign=top>Projection matrix (P) for first
irreducible</td>
</tr>
<tr>
<td valign=top>11-</td><td valign=top>Further bases and projections</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient workspace</td>
</tr>
</table>
Commentary: This implements the direct tensor condensation algorithm,
as described in Lux and Wiegelmann - Condensing Tensor Product
Modules, to which the user is referred for a fuller description of
condensation in general and tensor condensation in particular. There
are three other parts to the whole tensor condensation system, an
uncondense program <a href="#ztcv">ztcv</a>, a symmetry basis script
<a href="#sym_basis">sym_basis</a> and a small script <a
href="#qp">qp</a> to generate the basis and projection matrices.
</li>
<li>
<h3><a name="ztcocon">ztcocon</a></h3>
Purpose: Tensor condense continue
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Number of irreducibles of
condensation subgroup</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Multiplicities of tensor parameter
1</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Multiplicities of tensor parameter
2</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>File of irreducible dimensions for
condensation subgroup</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>File of endomorphism ring
dimensions for condensation subgroup</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Tensor parameter 1</td>
</tr>
<tr>
<td valign=top>7</td><td valign=top>Tensor parameter 2</td>
</tr>
<tr>
<td valign=top>8</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>9</td><td valign=top>Input</td>
</tr>
<tr>
<td valign=top>10</td><td valign=top>Loop number</td>
</tr>
<tr>
<td valign=top>11</td><td valign=top>Loop start point</td>
</tr>
<tr>
<td valign=top>12</td><td valign=top>Endomorphism ring basis (Q) for
first irreducible</td>
</tr>
<tr>
<td valign=top>13</td><td valign=top>Projection matrix (P) for first
irreducible</td>
</tr>
<tr>
<td valign=top>14-</td><td valign=top>Further bases and projections</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient workspace</td>
</tr>
</table>
Commentary: This program is to carry on where a preceding tenosr
condense has failed due to machine crash. It takes three extra
parameters not used by <a href=#ztco>ztco</a>, to specify the
condensed tensor so far, and at what point in the algorithm to
continue. The algorithm has an outer loop (parameter 0) controlling
which irreducible of the condensation subgroup is being dealt with, a
first inner loop (parameter 1) over the multiplicity of this
irreducible in the left tensor, and a second inner loop (parameter 2)
over the multiplicity of the given irreducible in the right tensor. A
continuation point can be specified for one of these three parameters.
The loop number takes values 0, 1 or 2 according to which parameter is
to be given. The loop start point then indicates the starting value of
the parameter in question. If an inner loop initial value is
specified, then all containing loops start at their maximum value.
See Lux and Wiegelmann - Condensing Tensor Product Modules for a
fuller description of condensation in general and tensor condensation
in particular.
</li>
<li>
<h3><a name="ztcv">ztcv</a></h3>
Purpose: Tensor uncondense
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Number of irreducibles of
condensation subgroup</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Multiplicities of tensor parameter
1</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Multiplicities of tensor parameter
2</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Input (condensed) rows</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Output (uncondensed) rows</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Endomorphism ring basis (Q) for
first irreducible</td>
</tr>
<tr>
<td valign=top>7-</td><td valign=top>Further bases</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient workspace</td>
</tr>
</table>
Commentary: This is the tensor uncondense section of the tensor
condensation system. It generates rows in the full (uncondensed)
space, with the same basis element ordering as is used by tensor
product.
</li>
<li>
<h3><a name="zte">zte</a></h3>
Purpose: Tensor product
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The left hand parameter</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>The right hand parameter</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for matrix plus workspace</td>
</tr>
</table>
Commentary: The tensor product is formed with the inner most loop
going over columns of parameter two. Thus the results looks like
blocks of scalar multiples of parameter two. It is important to
respect this ordering if a vector is to be brought in from for example
a tensor condense done by the Aachen meataxe. Either parameter may be
a map, and if both are, the result will be as well. Sufficient memory
must be provided to hold both parameters in store for the duration of
the program.
</li>
<li>
<h3><a name="ztmu">ztmu</a></h3>
Purpose: Multiply a matrix by a matrix in tensor form
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>First matrix</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Left hand tensor matrix</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Right hand tensor matrix</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Result matrix (or map)</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: When vectors are to be mutliplied by a tensor product, the
multiplication can be considerably simplified by regarding each vector
as an mxn matrix , where m is the dimension of the left hand part of
the tensor product, and n is the dimension of the right hand part of
the tensor product.
</li>
<li>
<h3><a name="ztr">ztr</a></h3>
Purpose: Transpose
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: This program can work by rereading the input as often as
is necessary to produce the output, however, it is most efficient if
sufficient room is provided to hold the entirity of the input in
memory. The input may also be a map, in which case the output will
also be a map, and the input must be square and invertible.
</li>
<li>
<h3><a name="ztrace">ztrace</a></h3>
Purpose: Compute the trace
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input matrix</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The trace, in the field of
definition of the input</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: This program provides a crude way of distinguishing
representations by looking at their traces on particular group
elements. It is not expected to be greatly used. The input must be
square.
</li>
<li>
<h3><a name="ztrecover">ztrecover</a></h3>
Purpose: Recover a file of vectors in tensor product form into normal
vector form
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input file</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Output file</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Number of columns in left hand tensor</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Number of columns in right hand tensor</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory</td>
</tr>
</table>
Commentary: Holding vectors in the form of an m x n matrix allows a
much more efficient multiplication by group elements in tensor product
space. In file, this form is achieved by normal vectors with "holes"
in them, so as to round up each column in the second argument to a
word length. This program compresses back to the normal form of the
vector, such as could be used with the full tensor product matrices,
eg for quotient space operations. Its main use is in recovering from
the situation where a tensor spin has produced a subspace, but the
program has been terminated before full closure has been established.
</li>
<li>
<h3><a name="ztsp">ztsp</a></h3>
Purpose: Produce a minimal subspace stable under the generators
containing a given vector. The generators are given as a tensor
product.
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The input vector</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>The subspace</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Generator 1 left hand</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Generator 1 right hand</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Generator 2 left hand</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Generator 2 right hand</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The subspace dimension, or if
memory is exhausted, the number of rows produced at that stage</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for subspace plus workspace</td>
</tr>
</table>
Commentary: This is a special case of <a href="#zmsp">zmsp</a> where the
generators are a tensor product. Replacing row multiplication by a
generator in tensor space, with two multiplications (with the left
hand generator transposed) gives an algorithm with a much better
complexity. If the individual dimensions are n and m, multiplication
in tensor space costs approximately n*n*m*m, whereas the two
multiplications that replace this cost n*m*m and n*n*m. The
improvement factor in the multiplication part of the algorithm is
therefore n*m/(n+m). The Gaussian elimination is done as before. We
arrange for the rows of each matrix representing a subspace vector to
be contiguous, so as far as Gaussian elimination is concerned, the
rows are potentially a little longer than one might otherwise expect,
with some columns always zero. This is transparent to the internals of
the program, and is only relevant when reading the module generator
and outputting the subspace.
</li>
<li>
<h3><a name="ztspf">ztspf</a></h3>
Purpose: Produce a minimal subspace stable under the generators
containing a given vector, using intermediate files. The generators
are given as a tensor product.
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The input vector</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>The subspace</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Generator 1 left hand</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Generator 1 right hand</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Generator 2 left hand</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Generator 2 right hand</td>
</tr>
<tr>
<td valign=top>7</td><td valign=top>Temporary workspace directory</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The subspace dimension, or if
memory is exhausted, the number of rows produced at that stage</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: This is a version of <a href="#ztsp">ztsp</a> using
intermediate files to overcome available main memory restrictions. The
temporary workspace directory must exist, this program will not create
it.
</li>
<li>
<h3><a name="zttov">zttov</a></h3>
Purpose: Convert a tensor to a flattened form, suitable for use by <a href="#ztmu">ztmu</a>
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: Essentially this takes each row of the input and places it
on the end of the preceding row, thus producing a single row with as
many columns as entries in the input tensor. Its inverse
is <a href="#zvtot">zvtot</a>. These, together
with <a href="#ztr">ztr</a> can be used to transpose the order of a
tensor product.
</li>
<li>
<h3><a name="zvp">zvp</a></h3>
Purpose: Vector permute
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input vector</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Output set of vectors</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Generator 2</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Permutation for generator 1</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Permutation for generator 2</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The number of points in the orbit</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for vectors plus workspace</td>
</tr>
</table>
Commentary: This does for permutations what <a href="#zmsp">zmsp</a>
does for modules. Its algorithms are in no way optimised, and anybody
wanting to produce seriously large permutation representations is
advised to use other published methods. It also produces the
permutations, since this information is calculated for free during the
process.
</li>
<li>
<h3><a name="zvpf">zvpf</a></h3>
Purpose: Vector permute using intermediate files
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Directory for temporary files</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Input vector</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Output set of vectors</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Generator 2</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Permutation for generator 1</td>
</tr>
<tr>
<td valign=top>7</td><td valign=top>Permutation for generator 2</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The number of points in the orbit</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory</td>
</tr>
</table>
Commentary: This is similar to <a href="#zlp">zlp</a>, but without
constraining the number of vectors to the total available memory.
</li>
<li>
<h3><a name="zvtot">zvtot</a></h3>
Purpose: Convert a vector to a tensor suitable for use by <a href="#ztr">ztr</a>
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Number of columns in output</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: This is the inverse of <a href="#zttov">zttov</a>. The
number of columns requested must be a divisor of the length of the
vector.
</li>
<li>
<h3><a name="zwords">zwords</a></h3>
Purpose: Produce a sequence of words in the generators
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Generator 2</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Output file stem</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Order of generator 1</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Order of generator 2</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The filenames corresponding to
each of the words in the generators</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: This program is provided to allow searching for random
words in the generators in a repeatable way, mainly to detect elements
of particular orders or in particular classes. All words start with
generator 1, since this is good enough to provide representatives of
every conjugacy class.
</li>
</ul>
<a name="Scripts">
<h1>Scripts</h1>
</a>
<p>
The scripts provide the glue that takes the tedium (and hopefully the
potential for error) out of the use of the lower level meataxe
programs. In general, the difference is that a program is expected
either to be computationally intensive (eg <a href="#zmu">zmu</a>, <a
href="#zmsp">zmsp</a>), or to deal with binary data. A script is
expected to be organisational. So, for example, there is a script to
split an entire module into its composition factors, record the
irreducibles, note when new irreducibles are found, and compute their
indicators when appropriate. This script is called <a
href="#split_all">split_all</a>, and itself depends on a number of
other scripts to perform its task. The Aachen meataxe has an
equivalent script, called chop.
</p>
<p>
Scripts generally follow the same conventions for error reporting as
the programs, but sometimes extend the range of error codes used, in
order to indicate conditions which aren't erroneous as such, but on
which a decision must be made. For example, if a script is asked to
split a representation using a particular given element, and that
element turns out to have nullity zero, then clearly a split cannot
take place. However, this is a very different class of error from a
missing or corrupted file.
</p>
<p>
As with the programs, there are some scripts which it is expected that
a user will invoke directly, and some which essentially subroutine
common pieces of calculation. For example, the user would certainly
make use of the various indicator calculation scripts, but would be
unlikely to invoke the preserves script (to see if a given generator
preserves a candidate quadratic form) directly.
</p>
<p>
It is also the case that as the dimension of the representation
increases, less and less of the automatic scripts will be used, since
the potential for massive wastage of time from a wrong decision within
such a script is much greater. So, for example, if I compute the skew
sqaure of the 112 for J4, then it makes sense to split it with <a
href="#split_all">split_all</a>. It makes no sense to try this on the
skew seventh of the 22 for Co3. Obviously, as machines become more
powerful, the crossover point between automatic and manual operation
will move in step, however, the computations at the limit of machine
capabilities will always be expected to be more manual.
</p>
<p>
The above does not mean that there is a point at which we would never
use a script (we will always use them to provide error free sequencing
of operations, eg indicator calculation). But it does mean that
speculative searching (eg as done by <a
href="#split_all">split_all</a>) becomes less and less useful as
dimension increases.
</p>
<ol>
<li><a href="#base">base</a></li>
<li><a href="#base_from_vector">base_from_vector</a></li>
<li><a href="#base_vectors">base_vectors</a></li>
<li><a href="#base_with_vector">base_with_vector</a></li>
<li><a href="#basef">basef</a></li>
<li><a href="#basef_from_vector">basef_from_vector</a></li>
<li><a href="#basef_vectors">basef_vectors</a></li>
<li><a href="#basef_with_vector">basef_with_vector</a></li>
<li><a href="#checkorder">checkorder</a></li>
<li><a href="#check_irred">check_irred</a></li>
<li><a href="#check_irredf">check_irredf</a></li>
<li><a href="#commutate">commutate</a></li>
<li><a href="#conjugate">conjugate</a></li>
<li><a href="#conjugatef">conjugatef</a></li>
<li><a href="#count_irreds">count_irreds</a></li>
<li><a href="#cut_cols">cut_cols</a></li>
<li><a href="#dual">dual</a></li>
<li><a href="#dual_subspace">dual_subspace</a></li>
<li><a href="#dual_with_order">dual_with_order</a></li>
<li><a href="#f1">f1</a></li>
<li><a href="#f10">f10</a></li>
<li><a href="#f2">f2</a></li>
<li><a href="#f3">f3</a></li>
<li><a href="#f4">f4</a></li>
<li><a href="#f5">f5</a></li>
<li><a href="#f6">f6</a></li>
<li><a href="#f7">f7</a></li>
<li><a href="#f8">f8</a></li>
<li><a href="#f9">f9</a></li>
<li><a href="#filter_element">filter_element</a></li>
<li><a href="#find_best_nullity_with_orders">find_best_nullity_with_orders</a></li>
<li><a href="#find_best_nullityf_with_orders">find_best_nullityf_with_orders</a></li>
<li><a href="#find_element">find_element</a></li>
<li><a href="#find_irred">find_irred</a></li>
<li><a href="#find_nullity_one_with_orders">find_nullity_one_with_orders</a></li>
<li><a href="#find_nullity_onef_with_orders">find_nullity_onef_with_orders</a></li>
<li><a href="#find_restricted_nullity_one_with_orders">find_restricted_nullity_one_with_orders</a></li>
<li><a href="#find_restricted_nullity_onef_with_orders">find_restricted_nullity_onef_with_orders</a></li>
<li><a href="#functions">functions</a></li>
<li><a href="#group_order">group_order</a></li>
<li><a href="#indicate">indicate</a></li>
<li><a href="#indicate_with_element">indicate_with_element</a></li>
<li><a href="#indicate_with_orders">indicate_with_orders</a></li>
<li><a href="#indicate_with_script">indicate_with_script</a></li>
<li><a href="#indicatef_with_element">indicatef_with_element</a></li>
<li><a href="#indicatef_with_script">indicatef_with_script</a></li>
<li><a href="#inner_product">inner_product</a></li>
<li><a href="#intersect">intersect</a></li>
<li><a href="#irred">irred</a></li>
<li><a href="#irr_base_change">irr_base_change</a></li>
<li><a href="#lift_vectors">lift_vectors</a></li>
<li><a href="#new_irred">new_irred</a></li>
<li><a href="#new_irred_and_indicate">new_irred_and_indicate</a></li>
<li><a href="#new_irred_and_indicate_with_orders">new_irred_and_indicate_with_orders</a></li>
<li><a href="#new_irred_with_orders">new_irred_with_orders</a></li>
<li><a href="#new_irred_with_script">new_irred_with_script</a></li>
<li><a href="#new_irredf_and_indicate_with_orders">new_irredf_and_indicate_with_orders</a></li>
<li><a href="#new_irredf_with_orders">new_irredf_with_orders</a></li>
<li><a href="#new_irredf_with_script">new_irredf_with_script</a></li>
<li><a href="#norm">norm</a></li>
<li><a href="#order">order</a></li>
<li><a href="#power">power</a></li>
<li><a href="#preserves">preserves</a></li>
<li><a href="#qp">qp</a></li>
<li><a href="#quick_order">quick_order</a></li>
<li><a href="#real_indicate">real_indicate</a></li>
<li><a href="#rebase.sh">rebase.sh</a></li>
<li><a href="#restrict_with_orders">restrict_with_orders</a></li>
<li><a href="#restrictf_with_orders">restrictf_with_orders</a></li>
<li><a href="#rip_rank">rip_rank</a></li>
<li><a href="#signature">signature</a></li>
<li><a href="#singular_order">singular_order</a></li>
<li><a href="#space_split">space_split</a></li>
<li><a href="#spin_vectors">spin_vectors</a></li>
<li><a href="#split">split</a></li>
<li><a href="#split_all">split_all</a></li>
<li><a href="#split_all_cond">split_all_cond</a></li>
<li><a href="#split_all_decomp">split_all_decomp</a></li>
<li><a href="#split_all_sub">split_all_sub</a></li>
<li><a href="#split_with_element">split_with_element</a></li>
<li><a href="#split_with_subspace">split_with_subspace</a></li>
<li><a href="#split_with_vectors">split_with_vectors</a></li>
<li><a href="#sym_basis">sym_basis</a></li>
<li><a href="#sym_basis_delta">sym_basis_delta</a></li>
<li><a href="#sym_basis_deltaf">sym_basis_deltaf</a></li>
<li><a href="#tensor_split_with_subspace">tensor_split_with_subspace</a></li>
<li><a href="#three">three</a></li>
<li><a href="#tspin_vectors">tspin_vectors</a></li>
<li><a href="#two">two</a></li>
</ol>
<ul>
<li>
<h3><a name="base">base</a></h3>
Purpose: Produce a standard base representation, given an element from
which to generate a seed.
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The element with which to split</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>A stem for output filenames</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Where to record the standard basis vectors</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Generator 1 (may be a map)</td>
</tr>
<tr>
<td valign=top>5-</td><td valign=top>Other generators (may be a map)</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>254</td><td valign=top>The representation reduced</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>The nullity was not 1 (so the seed is not unique)</td>
</tr>
</table>
Commentary: This script uses nullspace, standard base and invert, each
of which requires enough memory to store two input matrices, plus
about 10%. If this much memory is not available, the script <a
href="#basef">basef</a> should be used instead. The generators in
standard base are named &lt;stem&gt;_sb_{1,2}. The standard base
itself is also returned, for use in indicator calculations. The
inverse is not returned, although it could be if a need arose.
Generally, users are not expected to invoke this script directly.
</li>
<li>
<h3><a name="base_from_vector">base_from_vector</a></h3> Purpose:
Produce a standard base representation, given a seed
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The seed</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Output stem</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Memory to use</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Where to record the standard basis vectors</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Generator 1 (may be a map)</td>
</tr>
<tr>
<td valign=top>6-</td><td valign=top>Other generators (may be a map)</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>254</td><td valign=top>The representation reduced</td>
</tr>
</table>
Commentary: This script combines <a
href="#base_with_vector>base_with_vector</a> and <a
href="#conjugate">conjugate</a> to produce a standard basis and
convert the generators into it. Generally, users are not expected to
invoke this script directly.
</li>
<li>
<h3><a name="base_vectors">base_vectors</a></h3>
Purpose: Compute the vectors defining a standard base
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The element with which to split</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Where to record the standard basis vectors</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Generator 1 (may be a map)</td>
</tr>
<tr>
<td valign=top>4-</td><td valign=top>Other generators (may be a map)</td>
</tr>
<tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>254</td><td valign=top>The representation reduced</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>The nullity was not 1 (so the seed is not unique)</td>
</tr>
</table>
Commentary: This script is called from <a href="#base">base</a>, and also during the
calculation of indicators. It preforms the nullspace and standard base
part of <a href="#base">base</a>, but does not do the inversion or conjugation. This is
becuase, if we already know that an indicator will be + or - (but not
o), we do not need to conjugate the generators in the dual space back
into standard base form (and to do so is computationally expensive,
since it involves an invert and four multiplies). Generally, users are
not expected to invoke this script directly.
</li>
<li>
<h3><a name="base_with_vector">base_with_vector</a></h3> Purpose:
Produce a standard base, given a seed
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The seed</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Where to record the standard basis vectors</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Memory to use</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Generator 1 (may be a map)</td>
</tr>
<tr>
<td valign=top>5-</td><td valign=top>Other generators (may be a map)</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>254</td><td valign=top>The representation reduced</td>
</tr>
</table>
Commentary: This script performs the standard base spin part of the
full standard base process. Generally, users are not expected to
invoke this script directly.
</li>
<li>
<h3><a name="basef">basef</a></h3>
Purpose: A version of <a href="#base">base</a> using intermediate files
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The element with which to split</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>A stem for output filenames</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Where to record the standard basis vectors</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>A directory in which to place workspace files</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Amount of memory to provide to meataxe programs</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Generator 1 (may be a map)</td>
</tr>
<tr>
<td valign=top>7-</td><td valign=top>Other generators (may be a map)</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>254</td><td valign=top>The representation reduced</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>The nullity was not 1 (so the seed is not unique)</td>
</tr>
</table>
Commentary: This is a version of <a href="#base">base</a> using <a href="#znsf">znsf</a>,
<a href="#zmsbf">zmsbf</a> and <a href="#zivf">zivf</a> instead of <a
href="#zns">zns</a>, <a href="#zmsb">zmsb</a> and <a
href="#ziv">ziv</a>. These programs will work with more limited
amounts of memory, and so the amount to be used can be specified.
Otherwise, this script functions analogously to <a href="#base">base</a>. Note that the
temporary directory must exist, this script will not create it.
Generally, users are not expected to invoke this script directly.
</li>
<li>
<h3><a name="basef_from_vector">basef_from_vector</a></h3> Purpose:
Produce a standard base representation, given a seed
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The seed</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Output stem</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Where to record the standard basis vectors</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Directory for temporary files</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Memory</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Generator 1 (may be a map)</td>
</tr>
<tr>
<td valign=top>7-</td><td valign=top>Other generators (may be a map)</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>254</td><td valign=top>The representation reduced</td>
</tr>
</table>
Commentary: A version of <a
href="#base_from_vector>base_from_vector</a> using intermediate files.
Generally, users are not expected to invoke this script directly.
</li>
<li>
<h3><a name="basef_vectors">basef_vectors</a></h3>
Purpose: Compute the vectors defining a standard base, using
intermediate files
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The element with which to split</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Where to record the standard basis vectors</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>A directory in which to place workspace files</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Amount of memory to provide to meataxe programs</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Generator 1 (may be a map)</td>
</tr>
<tr>
<td valign=top>6-</td><td valign=top>Other generators (may be a map)</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>254</td><td valign=top>The representation reduced</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>The nullity was not 1 (so the seed is not unique)</td>
</tr>
</table>
Commentary: This is a version of <a
href="#base_vectors">base_vectors</a> using <a href="#znsf">znsf</a>
and <a href="#zmsbf">zmsbf</a> instead of <a href="#zns">zns</a> and <a
href="#zmsb">zmsb</a>. These programs will work with more limited
amounts of memory, and so the amount to be used can be specified.
Otherwise, this script functions analogously to <a
href="#base_vectors">base_vectors</a>. Note that the temporary
directory must exist, this script will not create it. Generally, users
are not expected to invoke this script directly.
</li>
<li>
<h3><a name="basef_with_vector">basef_with_vector</a></h3> Purpose:
Produce a standard base, given a seed
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The seed</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Where to record the standard basis vectors</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Directory for temporary files</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Memory to use</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Generator 1 (may be a map)</td>
</tr>
<tr>
<td valign=top>6-</td><td valign=top>Other generators (may be a map)</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>254</td><td valign=top>The representation reduced</td>
</tr>
</table>
Commentary: A version of <a
href="#base_with_vector">base_with_vector</a> using intermediate
files. Generally, users are not expected to invoke this script
directly.
</li>
<li>
<h3><a name="checkorder">checkorder</a></h3>
Purpose: Check the order of an invertible matrix
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Matrix</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Order</td>
</tr>
<tr>
<td valign=top>3-</td><td valign=top>Memory (optional)</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td
valign=top>"Order correct" or "Order wrong"</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Correct</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>Wrong</td>
</tr>
</table>
Commentary: This script is just to provide an easy way to sanity check
matrices. It uses power to optimise the computation. It will not spot
cases where the real order is a divisor of the input value.
</li>
<li>
<h3><a name="check_irred">check_irred</a></h3>
Purpose: Check a suspected irreducible really is irreducible
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Memory</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Script</td>
</tr>
<tr>
<td valign=top>3-</td><td valign=top>Generators</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td
valign=top>"irreducible" or "not irreducible"</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Irreducible</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>254</td><td valign=top>Nullity 0</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>Reducible</td>
</tr>
</table>
Commentary: This script is to automate the dual part of the Norton
irreducibility test. A typical scenario would be to create an
irreducible representation as a quotient of a subspace, using
generating vectors given by tensor condensation, then classify and
find the indicator for the irreducible, then use the expression
seeding the standard base as parameter 2 along with the algebra
generators after classification. The classification has already
performed one half of the Norton irreducibility test, and this script
performs the dual half.
</li>
<li>
<h3><a name="check_irredf">check_irredf</a></h3>
Purpose: Check a suspected irreducible really is irreducible
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Memory</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Script</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Directory for temporary files</td>
</tr>
<tr>
<td valign=top>4-</td><td valign=top>Generators</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td
valign=top>"irreducible" or "not irreducible"</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Irreducible</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>254</td><td valign=top>Nullity 0</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>Reducible</td>
</tr>
</table>
Commentary: This is a version of <a
href="#check_irred">check_irred</a> using intermediate files for the
nullspace and spin parts, which can therefore handle larger
representations than <a href="#check_irred">check_irred</a>.
</li>
<li>
<h3><a name="conjugate">conjugate</a></h3>
Purpose: Conjugate some elements, given an invertible matrix
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The element by which to conjugate</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>A stem for output filenames</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Generator 1 (may be a map)</td>
</tr>
<tr>
<td valign=top>4-</td><td valign=top>Other generators (may be a map)</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: This script uses invert, and forms G E (G inverse) for
each input G. Generally, users are not expected to invoke this script
directly.
</li>
<li>
<h3><a name="commutate">commutate</a></h3>
Purpose: Form the commutator [a,b] of a pair of invertible matrices a
and b
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>a</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>b</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>result</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Available memory (optional)</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: Does what it says on the tin, using two inversions and
three multiplies
</li>
<li>
<h3><a name="conjugatef">conjugatef</a></h3>
Purpose: Conjugate some elements, given an invertible matrix
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The element by which to conjugate</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>A stem for output filenames</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Directory for temporary files</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Memory</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Generator 1 (may be a map)</td>
</tr>
<tr>
<td valign=top>6-</td><td valign=top>Other generators (may be a map)</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: This script is a version of <a
href="#conjugate">conjugate<a/> using intermediate files. Generally,
users are not expected to invoke this script directly.
</li>
<li>
<li>
<h3><a name="count_irreds">count_irreds</a></h3>
Purpose: Count the irreducibles found by <a
href="#split_all">split_all</a> and similar scripts. Also report the
total dimension
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The directory of irreducibles to
be searched for</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>A file countaining the output of
<a href="#split_all">split_all</a> or similar</td>
</tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The
irreducibles with their multiplicities. Multiplicities of zero are
omitted. The total dimesopn is given at the end.</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>Non zero</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: This script is just for user convenience
</li>
<li>
<h3><a name="cut_cols">cut_cols</a></h3>
Purpose: Discard columns
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input vectors</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Number of columns required</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: This script is part of the mechanism for computing
intersections. It is not expected to be invoked directly by users.
</li>
<li>
<h3><a name="dual">dual</a></h3>
Purpose: Form the dual of a generator of a representation
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Optional memory size (default 200k)</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: This program works by inverting the transpose of the
generator. Inversion is computationally expensive as well as requiring
a lot of memory. If the order of the generator is known, then it may
be better to use <a href="#dual_with_order">dual_with_order</a>, which
inverts by producing an appropriate power of the element. In
particular, if the generator has order two, then no multiplication is
necessary. Many of the groups whose representations are studied using
the meataxe have one generator of order two. It is also worth noting
that when splitting the dual of a representation (eg to perform a
Norton irreducibility test), it is not necessary to invert the
transposes of the generators, since the group generated by the
transposes is the original group, in the dual representation. However,
if a split occurs, then either the sub and quotient space
representations must be transposed again, or the inversions done,
before attempting to classify any irreducibles found, since one is
otherwise no longer working with the same group generators, but rather
their inverses.
</li>
<li>
<h3><a name="dual_subspace">dual_subspace</a></h3>
Purpose: Find a subspace dual to a given subspace
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Optional memory size (default 200k)</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: This script is to produce a subspace giving a submodule of
the dual whose quotient dualises to the given space. Its main purpose
is to allow splitting of reprepsentations where Norton irreducibility
has been applied without passing permanently to the dual. It works by
computing the nullspace of the subspace produced in the dual
representation, and then putting this into echelon form using <a
href="#zbase">zbase</a>.
</li>
<li>
<h3><a name="dual_with_order">dual_with_order</a></h3>
Purpose: Form the dual of a generator of a representation, using
multiplication to perform the inversion
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Input</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Element order</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Optional memory size (default 200k)</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: The version of dual that performs inversion by powering.
All the caveats about care over the use of transposes apply equally
here.
</li>
<li>
<h3><a name="f1">f1</a></h3>
Purpose: A standard script to try when splitting. The script generates
A+B+C
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>A</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>B</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>C</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>A stem for the creation of temporary files</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: 
</li>
<li>
<h3><a name="f2">f2</a></h3>
Purpose: A standard script to try when splitting. The script generates
A+BC+C
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>A</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>B</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>C</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>A stem for the creation of temporary files</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: 
</li>
<li>
<h3><a name="f3">f3</a></h3>
Purpose: A standard script to try when splitting. The script generates
A+BC+B
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>A</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>B</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>C</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>A stem for the creation of temporary files</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: 
</li>
<li>
<h3><a name="f4">f4</a></h3>
Purpose: A standard script to try when splitting. The script generates
A+CB+B
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>A</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>B</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>C</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>A stem for the creation of temporary files</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: 
</li>
<li>
<h3><a name="f5">f5</a></h3>
Purpose: A standard script to try when splitting. The script generates
A+CB+C
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>A</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>B</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>C</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>A stem for the creation of temporary files</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: 
</li>
<li>
<h3><a name="f6">f6</a></h3>
Purpose: A standard script to try when splitting. The script generates
A+BC+CB
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>A</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>B</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>C</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>A stem for the creation of temporary files</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: 
</li>
<li>
<h3><a name="f7">f7</a></h3>
Purpose: A standard script to try when splitting. The script generates
A+BC+CB+B
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>A</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>B</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>C</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>A stem for the creation of temporary files</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: 
</li>
<li>
<h3><a name="f8">f8</a></h3>
Purpose: A standard script to try when splitting. The script generates
A+BC+CB+C
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>A</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>B</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>C</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>A stem for the creation of temporary files</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: 
</li>
<li>
<h3><a name="f9">f9</a></h3>
Purpose: A standard script to try when splitting. The script generates
A+B+CC
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>A</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>B</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>C</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>A stem for the creation of temporary files</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: 
</li>
<li>
<h3><a name="filter_element">filter_element</a></h3>
Purpose: A script for automating the search for delta words for use in
tensor condensation.
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Number of generators of the algebra</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>The nullity required on the first
representation (all other nullities will be zero)</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>A file containing the names of the
representations to be considered, with the representation to be
considered for non-zero nullity first. The generators for a particular
representation will be created by appending _1, _2 etc to the line
from this file giving that representation</td>
</tr>
<tr>
<td valign=top>4-</td><td valign=top>A number of formulae in the
generators, whose linear sums are to be tested as potential delta
words.</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>A number
of delta words (if found) for the first represnetation given</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: The script glues together the use of <a
href=#zcfl>zcfl</a>, <a href=#zfn>zfn</a> and <a href=#zfl>zpfl</a> to
find delta words for one representation.
</li>
<li>
<h3><a name="f10">f10</a></h3>
Purpose: A standard script to try when splitting. The script generates
A+BC+CC
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top></td>
</tr>
<tr>
<td valign=top>2</td><td valign=top></td>
</tr>
<tr>
<td valign=top>3</td><td valign=top></td>
</tr>
<tr>
<td valign=top>4</td><td valign=top></td>
</tr>
<tr>
<td valign=top>5</td><td valign=top></td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: 
</li>
<li>
<h3><a name="find_best_nullity_with_orders">find_best_nullity_with_orders</a></h3>
Purpose: Find an element of best nullity, given the orders of the
generators
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Memory size</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Order of generator 1</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Generator 2</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Order of generator 2</td>
</tr>
<tr>
<td valign=top>7-</td><td valign=top>Other generators and orders</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The script used to produce the element</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>No low nullity element found</td>
</tr>
</table>
Commentary: This is essentially a wrapper for <a href="#zfln">zfln</a>
</li>
<li>
<h3><a name="find_best_nullityf_with_orders">find_best_nullityf_with_orders</a></h3>
Purpose: Find an element of best nullity, given the orders of the
generators
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Memory size</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Directory for temporary files</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Order of generator 1</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Generator 2</td>
</tr>
<tr>
<td valign=top>7</td><td valign=top>Order of generator 2</td>
</tr>
<tr>
<td valign=top>8-</td><td valign=top>Other generators and orders</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The script used to produce the element</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>No low nullity element found</td>
</tr>
</table>
Commentary: This is essentially a wrapper for <a href="#zflnf">zflnf</a>
</li>
<li>
<h3><a name="find_element">find_element</a></h3>
Purpose: Find low nullity elements
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Number of generators</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Order of generator 1</td>
</tr>
<tr>
<td valign=top>4-</td><td valign=top>Other generators and orders</td>
</tr>
<tr>
<td valign=top>n</td><td valign=top>Depth of search</td>
</tr>
<tr>
<td valign=top>n+1</td><td valign=top>Nullity to be searched for</td>
</tr>
<tr>
<td valign=top>n+2</td><td valign=top>File in which nullities are to be recorded</td>
</tr>
<tr>
<td valign=top>n+3</td><td valign=top>Amount of memory available</td>
</tr>
<tr>
<td valign=top>n+4</td><td valign=top>Other representations to be considered</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>A
classification of group algebra elements having the required nullity
on few representations, and nullity zero on the rest</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: The purpose of this script is to discover group algebra
elements which pick out particular composition factor types in a
representation. Such elements are sometimes called delta words,
although the definition of a delta word is somewhat stricter. The goal
is to discover a vector which splits a representation, which is in
turn achieved by discovering an element of low nullity on the whole
representation. If condensation is available, then condensation is
normally a simpler route to obtaining given representations, however,
this technique is also applicable to splitting condensation
representations, for which no further condensation is available. An
example may make this clearer. Suppose we wish to split a
representation, because we know there is a new composition factor to
be found in it. Suppose further that we know that some already known
composition factor occurs a small number of times (eg one or two), and
we know bounds on the multiplicities of all other potential
composition factors. This may seems like a very contrived situation,
but in fact it is quite common, eg when one wishes to construct a
representation explicitly in order to compute its indicator, and the
full decomposition matrix is already known. Most new results obtained
so far with this meataxe have fallen into this category. In this
situation, one cannot afford to perform many subspace creations, or
many nullspace operations. However, forming group algebra elements in
the representation may be relatively easy, eg because it is a tensor
product, symmetrised power or permutation representation. We use this
program to enable us to find a group algebra element with nullity one
on our targetted composition factor, and hopefully nullity zero on all
others. We use null vectors from this element to seed our subspace
calculations. Once all factors targetted by this element have been
eliminated, we can use another element (again discovered using this
program). In this case, the search is easier, because one of the
composition factors has been eliminated from consideration.
Furthermore, we can avoid expensive multiplications in the production
of this new element, by creating it in the original representation,
and then carrying it through the splitting process. This point makes
it clear that it can be very important not to discard subspaces after
the sub and quotient space representations have been produced. The
values in paramters eight and onwards are of the form &lt;stem&gt;,
where &lt;stem&gt;_{1,2} are the real files. The other use of this
script is to find delta words for use when constructing symmetry bases
for condensation.
</li>
<li>
<h3><a name="find_irred">find_irred</a></h3>
Purpose: Identify the type of an existing irreducible
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Memory</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>3-</td><td valign=top>Other generators</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top> The
classified irreducible name for the given representation</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>254</td><td valign=top>Representation is reducible</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>Irreducible not found</td>
</tr>
</table>
Commentary: This script is used to classify irreducibles without going
through the effort of searching for a generator for the standard
basis, which in the case of representations which are not absolutely
irreducible, can be very time consuming. Instead, the set of known
irreducibles is searched for irreducibles of the correct degree, and
the script for each such is used to see if it can conjugate the given
representation into the standard form. The chief expected use of this
script is computing the endomorphism ring for an irreducible as part
of a tensor condensation, which requires the dual of a representation,
in its standard form.
</li>
<li>
<h3><a name="find_nullity_one_with_orders">find_nullity_one_with_orders</a></h3>
Purpose: Find an element of nullity one, given the orders of the
generators
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Memory size</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Order of generator 1</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Generator 2</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Order of generator 2</td>
</tr>
<tr>
<td valign=top>7-</td><td valign=top>Other generators and orders</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The script used to produce the element</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>No nullity one element found</td>
</tr>
</table>
Commentary: This is essentially a wrapper for <a
href="#zsums">zsums</a>
</li>
<li>
<h3><a name="find_nullity_onef_with_orders">find_nullity_onef_with_orders</a></h3>
Purpose: A version of <a
href="#find_nullity_one_with_orders">find_nullity_one_with_orders</a>
using intermediate files
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Memory size</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>A directory for workspace files</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Order of generator 1</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Generator 2</td>
</tr>
<tr>
<td valign=top>7</td><td valign=top>Order of generator 2</td>
</tr>
<tr>
<td valign=top>8-</td><td valign=top>Other generators and orders</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The script used to produce the element</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: As <a
href="#find_nullity_one_with_orders">find_nullity_one_with_orders</a>
but using <a href="#zsumsf">zsumsf</a>. Note that the temporary
directory must exist, this script will not create it.
</li>
<li>
<h3><a name="find_restricted_nullity_one_with_orders">find_restricted_nullity_one_with_orders</a></h3>
Purpose: A version of <a
href="#find_nullity_one_with_orders">find_nullity_one_with_orders</a>
where the coefficients are restricted to a subfield
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Order of subfield</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Memory size</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Order of generator 1</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Generator 2</td>
</tr>
<tr>
<td valign=top>7</td><td valign=top>Order of generator 2</td>
</tr>
<tr>
<td valign=top>8-:</td><td valign=top>Other generators and orders</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The script used to produce the element</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: Essentially the same as <a
href="#find_nullity_one_with_orders">find_nullity_one_with_orders</a>,
but calling <a href="#zrsums">zrsums</a> instead. See commentary on
zrsums for rationale.
</li>
<li>
<h3><a name="find_restricted_nullity_onef_with_orders">find_restricted_nullity_onef_with_orders</a></h3>
Purpose: A version of <a
href="#find_nullity_onef_with_orders">find_nullity_onef_with_orders</a>
where the coefficients are restricted to a subfield
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Order of subfield</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Memory size</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Memory size</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Order of generator 1</td>
</tr>
<tr>
<td valign=top>7</td><td valign=top>Generator 2</td>
</tr>
<tr>
<td valign=top>8</td><td valign=top>Order of generator 2</td>
</tr>
<tr>
<td valign=top>9-:</td><td valign=top>Other generators and orders</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The script used to produce the element</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: Essentially the same as <a
href="#find_nullity_onef_with_orders">find_nullity_onef_with_orders</a>,
but calling <a href="#zrsumsf">zrsumsf</a> instead. See commentary on
zrsums for rationale.
</li>
<li>
<h3><a name="functions">functions</a></h3>
Purpose: A set of functions used as subroutines by other scripts
<table>
<thead>
<td valign=top>Parameters:</td>
<td valign=top>None</t>
</thead>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
Commentary: Contains no user servicable parts
</li>
<li>
<h3><a name="group_order">group_order</a></h3>
Purpose: Compute the order of a group given a complete set of
irreducibles (not necessarily absolutely irreducible) in
characteristic not dividing the group order.
<table>
<thead>
<td valign=top>Parameters: None</td>
</thead>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The group order</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: This script computes the group order by summing the
squares of the representations degrees, each of which is divided by
the nullity of the seed word. The script can be used either to
confirm that all required representations have been found, or to
confirm that the group is the required group.
</li>
<li>
<h3><a name="indicate">indicate</a></h3>
Purpose: Compute the Frobenius-Schur indicator of a representation in
characteristic two
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Memory size</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Generator 2</td>
</tr>
<tr>
<td valign=top>4-</td><td valign=top>Other generators</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The indicator (+, - or o)</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: Indicators where the characteristic is not 2 can be
deduced from the decomposition matrix, and so are not supported by the
meataxe at present. In characteristic two the situation is different,
and this is one of very few areas where condensation methods appear
not to help. The resulting indicator is recorded in the name of a
symbolic link to the first group generator. All subsequent indicator
calculation scripts also do this.
</li>
<li>
<h3><a name="indicate_with_element">indicate_with_element</a></h3>
Purpose: Compute the Frobenius-Schur indicator of a representation in
characteristic two, given an element whose nullspace seeds a standard
base. 
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Element whose nullspace seeds the
standard base</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>The script used to create parameter 3</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Optional memory size (default 200k)</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Generator 1 in dual representation</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Generator 2</td>
</tr>
<tr>
<td valign=top>7</td><td valign=top>Generator 2 in dual representation</td>
</tr>
<tr>
<td valign=top>8-</td><td valign=top>Other generators and duals</td>
</tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The indicator (+, - or o)</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: The script (parameter 6) is only used to record with the
representation which group algebra element was used, for future
reference.
</li>
<li>
<h3><a name="indicate_with_orders">indicate_with_orders</a></h3>
Purpose: Compute the Frobenius-Schur indicator of a representation in
characteristic two, given the orders of the group generators. 
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Optional memory size (default 200k)</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Order of generator 1</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Generator 2</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Order of generator 2</td>
</tr>
<tr>
<td valign=top>6-</td><td valign=top>Other generators and orders</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The indicator (+, - or o)</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: This script is called by <a href="#indicate">indicate</a>
once the element orders have been computed, and in turn calls <a
href="#indicate_with_element">indicate_with_element</a> once an
element of nullity one has been identified.
</li>
<li>
<h3><a name="indicate_with_script">indicate_with_script</a></h3>
Purpose: Compute the Frobenius-Schur indicator of a representation in
characteristic two, given a script producing a group algebra element
of nullity one.
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The script used to create the element of nullity one</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Memory size</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Order of generator 1</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Generator 2</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Order of generator 2</td>
</tr>
<tr>
<td valign=top>7-</td><td valign=top>Other generators and orders</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The indicator (+, - or o)</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: This script computes the group algebra element from
parameter 3, the duals of the input generators, and then calls
<a href="#indicate_with_element">indicate_with_element</a>.
</li>
<li>
<h3><a name="indicatef_with_element">indicatef_with_element</a></h3>
Purpose: A version of <a
href="#indicate_with_element">indicate_with_element</a> using
intermediate files in the case where insufficient main memory is
available.
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Element whose nullspace seeds the
standard base</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>The script used to create parameter 3</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Memory size</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>A directory for temporary workspace files</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Generator 1 in dual representation</td>
</tr>
<tr>
<td valign=top>7</td><td valign=top>Generator 2</td>
</tr>
<tr>
<td valign=top>8</td><td valign=top>Generator 2 in dual representation</td>
</tr>
<tr>
<tr>
<td valign=top>9-</td><td valign=top>Other generators and duals</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The indicator (+, - or o)</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: This is essentially <a
href="#indicate_with_element">indicate_with_element</a>, except that
<a href="#znsf">znsf</a> and <a href="#zmsbf">zmsbf</a> are used in
place of <a href="#zns">zns</a> and <a href="#zmsb">zmsb</a>, to
overcome main memory limitations. Note that the temporary directory
must exist, this script will not create it.
</li>
<li>
<h3><a name="indicatef_with_script">indicatef_with_script</a></h3>
Purpose: A version of <a
href="#indicate_with_script">indicate_with_script</a> using
intermediate files
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The script used to create the element of nullity one</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Memory size</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>A directory for temporary nworkspace files</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Order of generator 1</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Generator 2</td>
</tr>
<tr>
<td valign=top>7</td><td valign=top>Order of generator 2</td>
</tr>
<tr>
<td valign=top>8-</td><td valign=top>Other generators and orders</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The indicator (+, - or o)</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: This is essentially <a
href="#indicate_with_script">indicate_with_script</a>, but using <a
href="#znsf">znsf</a> and <a href="#zmsbf">zmsbf</a> in place of <a
href="#zns">zns</a> and <a href="#zmsb">zmsb</a>. Having computed the
element required, it then calls <a
href="#indicatef_with_element">indicatef_with_element</a> to perform
the rest of the calculation. Note that the temporary directory must
exist, this script will not create it.
</li>
<li>
<h3><a name="inner_product">inner_product</a></h3>
Purpose: compute the inner product of two vectors or spaces with respect to a
form
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Memory available</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>First vector or space</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>The form</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Second vector or space</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The rank
of the product</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: This is a service script used in the calculation of
orthogonal group signs
</li>
<li>
<h3><a name="intersect">intersect</a></h3>
Purpose: Intersect two spaces
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Space 1</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Space 2</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>Only in
the case where the intersection is trivial</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: This works by joining the two spaces, producing null
vectors of the joined matrix, and forming linear sums after applying
<a href="#cut_cols">cut_cols</a> to the null vectors. There is
currently no file based version.
</li>
<li>
<h3><a name="irred">irred</a></h3>
Purpose: Perform Norton irreducibility test
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Element with which to split</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Stem for output filenames</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Memory size</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Name for subspace</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>6 onwards</td><td valign=top>Other generators</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>254</td><td valign=top>Failed to split (too many null vectors)</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>Irreducible</td>
</tr>
</table>
Commentary: The Norton irreducibility test states that if every null
vector of a group algebra element spins to the whole space, then
either the module is irreducible, or any null vector of the transpose
of the group algebra element provides a split in the dual. In
theoretical terms, the position is that there is a unique head in
which all the null vectors lie, and either this is the whole module,
or it is a unique socle in the dual. It is also worth noting, that if
the dual is split using a null vector from the transposed original
element by this process, then the subspace so obtained is irreducible.
The program returns the subspace found within the dual, from which a
dual dual subspace can be found in the original using <a
href="#dual_subspace">dual_subspace</a>.
</li>
<li>
<h3><a name="irr_base_change">irr_base_change</a></h3>
Purpose: Rebase a set of irreducibles according to scripts
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Memory</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>File of scripts</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>File of irreducible name stems</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Number of generators</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>As for <a href="#new_irred_with_script">new_irred_with_script</a></td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: This script is used to change the seed for irreducibles as
a preliminary to computing a symmetry basis for tensor condensation.
</li>
<li>
<h3><a name="lift_vectors">lift_vectors</a></h3>
Purpose: Lift some vectors back through a number of quotient operations
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Output subspace</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Input set of vectors</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Memory size</td>
</tr>
<tr>
<td valign=top>4 onwards</td><td valign=top>Other input subspaces, in order</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: The intention is to provide a recursive lift and join
operation, giving the full subspace of a larger representation
corresponding to a smaller subspace of some quotient.
</li>
<li>
<h3><a name="new_irred">new_irred</a></h3>
Purpose: Classify a potential new irreducible
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Memory size</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>other generators</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td
valign=top>Information indicating either that this is new or, if
already known, which known irreducible it is.</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>254</td><td valign=top>No nullity one element found</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>Module is a known irreducible</td>
</tr>
</table>
Commentary: This script works by first computing the orders, and then
calling <a href="#new_irred_with_orders">new_irred_with_orders</a>. If
the orders are already known, it is almost certainly better to call <a
href="#new_irred_with_orders">new_irred_with_orders</a> directly.
Computing element orders in large representations is time consuming.
</li>
<li>
<h3><a name="new_irred_and_indicate">new_irred_and_indicate</a></h3>
Purpose: Classify a potential new irreducible. In characteristic two,
find its indicator
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Memory size</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Other generators</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>Information indicating either that
this is new or, if already known, which known irreducible it is. For a
new module in characteric two, the indicator is also given.</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>254</td><td valign=top>No nullity one element found</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>Module is a known irreducible</td>
</tr>
</table>
Commentary: This script works by first computing the orders, and then
calling <a
href="#new_irred_and_indicate_with_orders">new_irred_and_indicate_with_orders</a>.
If the orders are already known, it is almost certainly better to call
<a
href="#new_irred_and_indicate_with_orders">new_irred_and_indicate_with_orders</a>
directly. Computing element orders in large representations is time
consuming. This script is called directly from <a
href="#split_all">split_all</a>.
</li>
<li>
<h3><a name="new_irred_and_indicate_with_orders">new_irred_and_indicate_with_orders</a></h3>
Purpose: Classify a potential new irreducible, given the orders of the
generators. In characteristic two, find its indicator.
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Memory size</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Order of generator 1</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Generator 2</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Order of generator 2</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Other generators and orders</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>Information indicating either that
this is new or, if already known, which known irreducible it is. For a
new module in characteric two, the indicator is also given.</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>254</td><td valign=top>No nullity one element found</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>Module is a known irreducible</td>
</tr>
</table>
Commentary: As for <a
href="#new_irred_and_indicate">new_irred_and_indicate</a>.
</li>
<li>
<h3><a name="new_irred_with_orders">new_irred_with_orders</a></h3>
Purpose: Classify a potential new irreducible, given the orders of the
generators.
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Memory size</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Order of generator 1</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Generator 2</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Order of generator 2</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Other generators and orders</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>Information indicating either that
this is new or, if already known, which known irreducible it is.</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>254</td><td valign=top>No nullity one element found</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>Module is a known irreducible</td>
</tr>
</table>
Commentary: As for <a href="#new_irred">new_irred</a>.
</li>
<li>
<h3><a name="new_irred_with_script">new_irred_with_script</a></h3>
Purpose: Classify a potential new irreducible, given the script
producing the element whose nullspace seeds the standard base
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Memory size</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Script giving the required element</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Generator 2</td>
</tr>
<tr>
<td valign=top>5-</td><td valign=top>Other generators</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>Information indicating either that
this is new or, if already known, which known irreducible it is.</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>254</td><td valign=top>Script does not produce a nullity one element</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>Module is a known irreducible</td>
</tr>
</table>
Commentary: As for <a href="#new_irred">new_irred</a>.
</li>
<li>
<h3><a name="new_irredf_and_indicate_with_orders">new_irredf_and_indicate_with_orders</a></h3>
Purpose: Classify a potential new irreducible, given the orders of the
generators. In characteristic two, find its indicator. Use intermdiate files.
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Memory size</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>A directory for temporary files</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Order of generator 1</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Generator 2</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Order of generator 2</td>
</tr>
<tr>
<td valign=top>7</td><td valign=top>Other generators and orders</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>Information indicating either that
this is new or, if already known, which known irreducible it is. For a
new module in characteric two, the indicator is also given.</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>254</td><td valign=top>No nullity one element found</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>Module is a known irreducible</td>
</tr>
</table>
Commentary: As for <a
href="#new_irred_and_indicate">new_irred_and_indicate</a>.
</li>
<li>
<h3><a name="new_irredf_with_orders">new_irredf_with_orders</a></h3>
Purpose: A version of <a
href="#new_irred_with_orders">new_irred_with_orders</a> using
intermediate files
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Memory size</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Directory for temporary files</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Order of generator 1</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Generator 2</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Order of generator 2</td>
</tr>
<tr>
<td valign=top>7-</td><td valign=top>Other generators and orders</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td
valign=top>Information indicating either that this is new or, if
already known, which known irreducible it is.</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>254</td><td valign=top>No nullity one element found</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>Module is a known irreducible</td>
</tr>
</table>
Commentary: This script replaces the use of <a href="#zns">zns</a>, <a
href="#zmsb">zmsb</a> and <a href="#ziv">ziv</a> with <a
href="#znsf">znsf</a>, <a href="#zmsbf">zmsbf</a> and <a
href="#zivf">zivf</a> in order to cope with situations where
insufficient main memory is available. Otherwise, it is similar to the
non file based version. Note that the temporary directory must exist,
this script will not create it.
</li>
<li>
<h3><a name="new_irredf_with_script">new_irredf_with_script</a></h3>
Purpose: Intermediate file version of <a
href="new_irred_with_script">new_irred_with_script</a>
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Memory size</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Directory for temporary files</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Script giving the required element</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Generator 2</td>
</tr>
<tr>
<td valign=top>6-</td><td valign=top>Other generators</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>Information indicating either that
this is new or, if already known, which known irreducible it is.</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>254</td><td valign=top>Script does not produce a nullity one element</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>Module is a known irreducible</td>
</tr>
</table>
Commentary: As for <a href="#new_irredf_with_orders">new_irredf_with_orders</a>.
</li>
<li>
<h3><a name="norm">norm</a></h3>
Purpose: compute the norm of a vector with respect to a form
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Memory available</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Vector</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>The form</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The rank
of the inner product of the vector with itself (0 or 1)</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: This is a service script used in the calculation of
orthogonal group signs
</li>
<li>
<h3><a name="order">order</a></h3>
Purpose: Compute the order of a matrix or map
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The matrix or map</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The order</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: This script is used internally by scripts such as <a
href="#new_irred">new_irred</a>. It is also useful on the command
line, eg in <tt>new_irred_with_orders c_1 c_2 `order irreds/24_0_1`
`order irreds/24_0_2` 500000</tt> where we do not wish the order to be
computed using large matrices. It first computes the rank to ensure
that time is not wasted on singular input.
</li>
<li>
<h3><a name="power">power</a></h3>
Purpose: Compute a power of a matrix or map
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The element to be powered</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>The index</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Output</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Optional memory size (default 200k)</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: Power zero returns an identity. Power 1 returns the input.
Otherwise, the script computes all powers necessary by repeated
squaring, and then multiplies the relevant ones to deliver the result.
</li>
<li>
<h3><a name="preserves">preserves</a></h3>
Purpose: A script internal to indicator calculation
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>A matrix representing a quadratic form</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>The corresponding symmetrized form</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>The element of the group</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>The field element on the form diagonal</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Optional memory size (default 200k)</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>The form is preserved</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>The form is not preserved</td>
</tr>
</table>
Commentary: Because the group element g is in standard base form, it
is sparse. We therefore always use it on the left of multiplications,
transposing if necessary to achieve this. Because of this, we never
need g transpose. We also do not transpose the form Q, as we are only
interested in the resulting diagonal and the resulting symmetrized
sum. This does provide significant speed improvements, particularly in
larger dimensions.
</li>
<li>
<h3><a name="qp">qp</a></h3>
Purpose: Produce the matrices Q and P required for tensor
condensation.
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>E, the sum over the condensation
subgroup modulo its order, in the given representation</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Memory</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>The matrix Q, a basis for the
space spanned by the rows of E</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>The matrix P, such that E = PQ</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: This just a service script for the tensor condensation and
uncondensation algorithm. For each irreducible representation X of the
condensation subgroup we compute E(X) as the fixed space of X x
dual(X) on the condensation subgroup. Q and P are then derived as
above.
</li>
<li>
<h3><a name="quick_order">quick_order</a></h3>
Purpose: Compute the order of a matrix or map. Terminate if greater
than 10
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The matrix or map</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The order</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: This is a version of <a href="#order">order</a> which
terminates after the order is proved greater than 10. It is therefore
suitable for use in situations when the actuial order is not needed,
but merely a lower bound on the number of distinct powers of the
element is required. It first computes the rank to ensure that time is
not wasted on singular input.
</li>
<li>
<h3><a name="real_indicate">real_indicate</a></h3>
Purpose: Compute the indicator of a representation known to be self
dual, for which we have the standard basis conjugating the dual to the
original
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The standard basis for the dual</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Initial memory size</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Temporary directory for use by zsignf</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Generator 2</td>
</tr>
<tr>
<td valign=top>6-</td><td valign=top>Other generators</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The indicator (+ or -)</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: This script is common code within <a
href="#indicate_with_element">indicate_with_element</a>, <a
href="#indicatef_with_element">indicatef_with_element</a>. It performs
the loop over the field elements part of the calculation, looking for
a diagonal value for a potential quadratic form.
</li>
<li>
<h3><a name="rebase.sh">rebase.sh</a></h3>
Purpose: Create standard bases for a set of irreducibles with a given
set of group algebra words used to generate the null vector seeds
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The list of words to be used for
creating group algebra elements</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>The set of existing irreducibles</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>The number of generators</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>As from <a
href=#new_irred_with_script>new_irred_with_script</a></td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: This script is normally used as part of tensor
condensation, to ensure that the delta words used to compute the
symmetry basis are the same as those used to seed the irreducible
representations from which the P and Q matrices are created.
</li>
<li>
<h3><a name="restrict_with_orders">restrict_with_orders</a></h3>
Purpose: Attempt to restrict a representation to a subfield
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Memory size</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Subfield order</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Stem for output filenames</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Order generator 1</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Generator 2</td>
</tr>
<tr>
<td valign=top>7</td><td valign=top>Order generator 2</td>
</tr>
<tr>
<td valign=top>8-:</td><td valign=top>Other generators and orders</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>254</td><td valign=top>No nullity one element found over subfield</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Representation does not restrict</td>
</tr>
</table>
Commentary: This script works on the assumption that if a
representation restricts to a subfield, then we can find an element of
nullity one with coefficients in that subfield, and that element will
give a standard base where the group elements are represented with
entries restricted to the subfield. If the representation does not
restrict to the subfield, then we may either fail because we cannot
find an element of nullity one, or because the standard base
representation relative to that element's null vector has entries
outside of the subfield. One can use the program <a
href="#zconj">zconj</a> to produce the conjugate representation first,
and thus determine precisely whether or not the representation does
restrict. From a theoretical point of view, the field necessary for
the representation is precisely the field necessary for the character
values, so if the character is known this again gives precise
information.
</li>
<li>
<h3><a name="restrictf_with_orders">restrictf_with_orders</a></h3>
Purpose: Attempt to restrict a representation to a subfield
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Memory size</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Subfield order</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Stem for output filenames</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Temporary file directory</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Order generator 1</td>
</tr>
<tr>
<td valign=top>7</td><td valign=top>Generator 2</td>
</tr>
<tr>
<td valign=top>8</td><td valign=top>Order generator 2</td>
</tr>
<tr>
<td valign=top>9-:</td><td valign=top>Other generators and orders</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>254</td><td valign=top>No nullity one element found over subfield</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Representation does not restrict</td>
</tr>
</table>
Commentary: This script is similar to <a
href="#restrict_with_orders">restrict_with_orders</a>, except that
intermediate files are used to cope with insufficient memory
requirements.
</li>
<li>
<h3><a name="rip_rank">rip_rank</a></h3>
Purpose: Compute the size of the fixed subspace of a cyclic subgroup
on a representation
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Generator A</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Generator B</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Order of AB</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Output (sum over elements of &lt;AB&gt;)</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The rip-off rank</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: The word rip in the name of this script is derived from
the original name for condensation, which was rip-off. The script
computes the sum over the group generated by the product of the two
generators, and then calculates its rank. It also delivers the sum
element.
</li>
<li>
<h3><a name="signature">signature</a></h3>
Purpose: Compute a crude signature of a representation by evaluating
its rank on each of the scripts <a href="#f1">f1</a> - <a
href="#f10">f10</a>
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Generator 2</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The rank on each of the f scripts</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: This script can be used to provide some identification for
representations, in the sense that if their signatures are different,
then they cannot be isomorphic. Of course, the converse is untrue. It
can also be used as a very restricted search for low nullity group
algebra elements, and in order to avoid pathologically bad elements
(it is quite possible for one or more of the f scripts to have
unusably high nullity on a representation, and it is worth knowing
this in advance, rather than letting <a
href="#split_all">split_all</a> waste a lot of time trying a large
number of useless null vectors).
</li>
<li>
<h3><a name="singular_order">singular_order</a></h3>
Purpose: Compute an analog of order of a matrix or map, where the
matrix is potentially singular
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The matrix or map</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The order</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported
textually by the program</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>Rank 0</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: This script is used internally by scripts such as <a
href="#split">split</a>. The intention is that we wish, up to a limit
of five, to determine how many distinct ranks the matrix has. This is
really just to compute a useful number to feed to programs such as <a
href="#zsums">zsums</a>.
</li>
<li>
<h3><a name="space_split">space_split</a></h3>
Purpose: Split a set of vectors via a subspace. Two results are
produced, one a basis of the vectors in the subspace, and the other a
basis completing the space, but with trivial intersection with the
subspace.
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The subspace</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>The vectors to be split</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Output stem</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Optional memory size (default 400k)</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The
dimensions of the subspace and quotient</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory supplied</td>
</tr>
</table>
Commentary: This script provides a means of acquiring the intersection
of a space with a set of vectors, and a direct complement for that
intersection within the set of vectors. The outputs are parameter3.ss
and parameter3.proj.
</li>
<li>
<h3><a name="spin_vectors">spin_vectors</a></h3>
Purpose: Spin a number of vectors under restricted memory constraints,
until a subspace is found
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>A set of vectors to be tried</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>The number of vectors to be used</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>The number of the first vector to
be used</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>The amount of memory to use for <a
href="#zmsp">zmsp</a></td>
</tr>
<tr>
<td valign=top>5 onwards</td><td valign=top>The generators</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>Information about each vector tried</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>No subspace found within the constraints of memory</td>
</tr>
</table>
Commentary: This script is intended for searching a set of vectors for
one generating a small subspace. The typical use situation is where one knows
theoretically that one of the vectors will produce a small subspace,
and one knows a bound for the dimension of that subspace, and one
wishes to avoid other potentially much larger subspaces. A particular
case is where the subspace sought is an irreducible, and spinning
until closure might equally well produce the corresponding head, ie
the whole space.
</li>
<li>
<h3><a name="split">split</a></h3>
Purpose: Perform a single split of a representation
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Output stem</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Ignore pathology</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Vectors used to seed the split (output)</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>The subspace found (output)</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>6-</td><td valign=top>Other generators</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>Information describing the split
(or lack of split)</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>252</td><td valign=top>Failed to find an element with which to split</td>
</tr>
<tr>
<td valign=top>254</td><td valign=top>Failed to split for some other reason</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>Irreducible found</td>
</tr>
</table>
Commentary: This script searches though the standard f scripts for a
suitable splitting element, and if that fails either to split or
determine irreducibility, it then uses <a href="#zsums">zsums</a>. It
can therefore fail if the generators are singular. Because this script
does a lot of searching for suitable elements, it should be used
carefully, either on very small cases, or on cases which are known to
split easily. The extra parameter ignore pathology is normally set to
1 (true) to cause it to ignore elements with very large nullities.
However, when splitting a representation which is completely reducible
(eg for a condensation subgroup), these elements may be the only ones
that can provide suitable vectors. Under these circumstances, the
parameter ignore pathology should be set to 0, as is done by the
driving script <a href="split_all_decomp">split_all_decomp</a>. The
script returns the vectors used to seed the split, and the subspace
found. These can then be used to assist with splitting the subspace
and quotient (using <a href="space_split">space_split</a> to get the
projections and subspace vectos), thus avoiding potentially costly
searches for splitting elements.
</li>
<li>
<h3><a name="split_all">split_all</a></h3>
Purpose: A driver script to call <a href="#split">split</a>
recursively to achieve a reduction into composition factors
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Stem for output file names</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>3 onwards</td><td valign=top>Other generators</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>Information describing the split
(or lack of split)</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>252</td><td valign=top>Ran out out of possible elements with which to
split</td>
</tr>
</table>
Commentary: Because this script does a lot of searching for suitable
elements, it should be used carefully, either on very small cases, or
on cases which are known to split easily. This applies even more than
for split, since this script will continue until all pieces found are
irreducible.
</li>
<li>
<h3><a name="split_all_cond">split_all_cond</a></h3>
Purpose: A driver script to call <a href="#split">split</a>
recursively to achieve a reduction into composition factors. This
script is specifically intended for condensations, where indicators
are not to be calculated.
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Stem for output file names</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>3 onwards</td><td valign=top>Other generators</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>Information describing the split
(or lack of split)</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>252</td><td valign=top>Ran out out of possible elements with which to
split</td>
</tr>
</table>
Commentary: Because this script does a lot of searching for suitable
elements, it should be used carefully, either on very small cases, or
on cases which are known to split easily. This applies even more than
for split, since this script will continue until all pieces found are
irreducible.
</li>
<li>
<h3><a name="split_all_decomp">split_all_decomp</a></h3>
Purpose: A driver script to call <a href="#split">split</a>
recursively to achieve a reduction into composition factors. This
script is specifically for condensation subgroups, where
representations are completely reducible, and low nullity group
algebra elements may not exist
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Stem for output file names</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>3 onwards</td><td valign=top>Other generators</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>Information describing the split
(or lack of split)</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>252</td><td valign=top>Ran out out of possible elements with which to
split</td>
</tr>
</table>
Commentary: Because this script does a lot of searching for suitable
elements, it should be used carefully, either on very small cases, or
on cases which are known to split easily. This applies even more than
for split, since this script will continue until all pieces found are
irreducible.
</li>
<li>
<h3><a name="split_all_sub">split_all_sub</a></h3>
Purpose: The main code common to <a href="#split_all">split_all</a>,
<a href="#split_all_cond">split_all_cond</a> and <a
href="#split_all_decomp">split_all_decomp</a>.
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Stem for output file names</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>1 for indicators, 0 for not. Other
values reserved for future expansion</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>1 to ignore elements with
pathologically large nullities, 0 to use them. Other values reserved
for future expansion</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>The vectors to try first when splitting</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>6 onwards</td><td valign=top>Other generators</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td
valign=top>Information describing the split (or lack of split)</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported
textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>252</td><td valign=top>Ran out out of possible elements with which to
split</td>
</tr>
</table>
Commentary: Because this script does a lot of searching for suitable
elements, it should be used carefully, either on very small cases, or
on cases which are known to split easily. This applies even more than
for split, since this script will continue until all pieces found are
irreducible. In order to ease the problem of searching through
elements which are known to be no use (because the calling split found
them to have nullity zero), this script can be provided via parameter
4 with some vectors to try first, which will typically have come from a
nullspace operation yielding non-zero nullity.
</li>
<li>
<h3><a name="split_with_element">split_with_element</a></h3>
Purpose: Split a representation using the nullspace of a given element
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Element with which to split</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Stem for output file names</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>A counter to prevent looping</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>A boolean to allow or disallow pathological elements</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>The subspace produced</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>The null vectors used to seed the subspace</td>
</tr>
<tr>
<td valign=top>7</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>8 onwards</td><td valign=top>Other generators</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td
valign=top>Information describing the split (or lack of split)</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>253</td><td valign=top>Nullity 0</td>
</tr>
<tr>
<td valign=top>254</td><td valign=top>Did not split (probably too many null vectors)</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>Irreducible</td>
</tr>
</table>
Commentary: This script actually performs a single split with a given
element, transposing and recursing if necessary via the script irred.
In order to prevent an infinite loop, a count of calls is passed in
via parameter 3. If this count is not zero, then the assumption is
that we have been called recursively, and that therefore if a single
vector spins to the whole space then the representation is
irreducible, as per the Norton irreducibility test. So, if this script
is called from the command line, parameter 3 should be set to 0. A
further parameter to allow or disallow pathologically low nullities is
passed in in parameter 4. This script regards any nullity whose square
exceeds the dimension of the representation as bad, and will, if
parameter 4 is set non-zero, refuse to use it to split. However, in
some cases, all singular elements may turn out to be bad, eg a cyclic
group of order 3 in a two dimensional representation ovr GF2. Use of
parameter 4 can allow manual overriding of what scripts such as <a
href=#split_all>split_all</a> and <a href=#split>split</a> do. Output
files of the form &lt;stem&gt;_&lt;nor&gt;_&lt;subnor&gt;_{1,2,...}
are produced, where &lt;stem&gt; is parameter 2, &lt;nor&gt; is the
incoming number of rows, and &lt;subnor&gt; is the subspace dimension
or codimension as appropriate. In the case where the dimension and
codimension are the same, the subscripts _a and _b are appended after
&lt;subnor&gt;. If the name produces a clash with an existing
filename, the subscripts _1, _2 etc are added to &lt;stem&gt; before
forming the name until a non-clashing name is found. This is
particularly important in the case where this script is called from <a
href="#split_all">split_all</a>, as a number of pieces of a
representation may have been queued awaiting processing, and name
clashes can easily occur. In the case where the Norton irreducibility
test is invoked, a dual dual subspace is produced in the original
using <a href="#dual_subspace">dual_subspace</a>. The subspace is
returned via parameter 5, and the null vectors used to seed it via
parameter 6.
</li>
<li>
<h3><a name="split_with_subspace">split_with_subspace</a></h3>
Purpose: Given a subspace, produce the sub and quotient
representations of an element of the group algebra
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<td valign=top>1</td><td valign=top>The subspace</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>The stem of the name to be given
    to the subspace representation for parameters 5-</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>The stem of the name to be given
    to the quotient space representation for parameters 5-</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Memory size</td>
</tr>
<tr>
<td valign=top>5-</td><td valign=top>Elements acting on the whole space</td>
</tr>
<tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>254</td><td valign=top>Subspace is whole space</td>
</tr>
</table>
Commentary: This is really just a script to wrap up the relevant use
of <a href="#zmu">zmu</a>, <a href="#zss">zss</a> and <a
href="#zqs">zqs</a> for the same parameters.
</li>
<li>
<h3><a name="split_with_vectors">split_with_vectors</a></h3>
Purpose: Split a representation using a collection of vectors
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Vectors with which to split</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Stem for output file names</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>A boolean to allow or disallow pathological elements</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>The subspace produced</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Generator 1</td>
</tr>
<tr>
<td valign=top>6 onwards</td><td valign=top>Other generators</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td
valign=top>Information describing the split (or lack of split)</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>254</td><td valign=top>Did not split (probably too many null vectors)</td>
</tr>
</table>
Commentary: This script tries to split using each possible element
from the sapn of the vectors, or some restricted subset thereof if the
span is too large. It returns the subspace found, as well as
performing the subspace and quoteient space operations. The naming
conventions are as for <a href="split_with_element">
split_with_element<a/>. Norton irreducibility is not applied.
</li>
<li>
<h3><a name="split_with_subspace">split_with_subspace</a></h3>
Purpose: Given a subspace, produce the sub and quotient
representations of an element of the group algebra
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Any element acting on the whole space</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>The subspace</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>The name to be given to the subspace representation for
parameter 1</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>The name to be given to the quotient space
representation for parameter 1</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Optional memory size (default 200k)</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>254</td><td valign=top>Subspace is whole space</td>
</tr>
</table>
Commentary: This is really just a script to wrap up the relevant use
of <a href="#zmu">zmu</a>, <a href="#zss">zss</a> and <a
href="#zqs">zqs</a> for the same parameters.
</li>
<li>
<h3><a name="sym_basis">sym_basis</a></h3>
Purpose: Produce a symmetry basis with respect to a p'-subgroup
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>A file containing the names of the
irreducibles, in the required order</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Memory</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Output basis</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Output multiplicities</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>Script to produce the gamma
operator for a given irreducible and module</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>First generator of condensation subgroup</td>
</tr>
<tr>
<td valign=top>7-</td><td valign=top>Other generators</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>Error messages</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: This script produces a symmetry basis for a given
representation, as defined in Lux and Wiegelmann. The generators given
generate the condensation subgroup, and the output is a basis by which
the full group generators can be conjugated to give them relative to
the symmetry basis, plus the file of multiplicities required by <a
href="#ztco">ztco</a>. The gamma operator script takes five or more
parameters, specifying the generator count, the stem for the
irreducible, the memory to be used, the output, and the generators in
the representation for which a symmetry basis is being produced. Such
a script is relatively easy to write when the condensation subgroup is
a non-abelian q.p group (eg 11.5).
</li>
<li>
<h3><a name="sym_basis_delta">sym_basis_delta</a></h3>
Purpose: Produce a symmetry basis with respect to a p'-subgroup
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>A file containing the names of the
irreducibles, in the required order</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Memory</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Output basis</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Output multiplicities</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>File of delta word scripts for the
irreducibles in use</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>First generator of condensation subgroup</td>
</tr>
<tr>
<td valign=top>7-</td><td valign=top>Other generators</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>Error messages</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: This script produces a symmetry basis for a given
representation, as defined in Lux and Wiegelmann. The generators given
generate the condensation subgroup, and the output is a basis by which
the full group generators can be conjugated to give them relative to
the symmetry basis, plus the file of multiplicities required by <a
href="#ztco">ztco</a>. The delta words scripts give delta words for the
individual representations, in the same order as the names of the
irreducibles in parameter 1. Such delta words can be found using the
<a href="find_element">find_element</a> script. Note that having found
these delta words, the irreducibles for the condensation subgroup must
be classified using them, rather than those found in the normal zsums
search order. From these will be produced the E, Q and P matrices,
which have a correspondence with the symmetry basis produced here.
</li>
<li>
<h3><a name="sym_basis_deltaf">sym_basis_deltaf</a></h3>
Purpose: Produce a symmetry basis with respect to a p'-subgroup, using
intermediate files for nullspaces and spins
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>A file containing the names of the
irreducibles, in the required order</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Memory</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Output basis</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Output multiplicities</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>File of delta word scripts for the
irreducibles in use</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>Directory in whic to create
temporary files</td>
</tr>
<tr>
<td valign=top>7</td><td valign=top>First generator of condensation subgroup</td>
</tr>
<tr>
<td valign=top>7-</td><td valign=top>Other generators</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>Error messages</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
</table>
Commentary: As <a href="sym_basis_delta">sym_basis_delta</a>, but
using intermediate files.
</li>
<li>
<h3><a name="tensor_split_with_subspace">tensor_split_with_subspace</a></h3>
Purpose: Given a subspace, produce the sub and quotient
representations of an element of the group algebra, with an expression
as a tensor
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>Any element acting on the whole space</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>The subspace</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>Left hand tensor for parameter 1</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>Right hand tensor for parameter 1</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>The name to be given to the subspace representation for
parameter 1</td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>The name to be given to the quotient space
representation for parameter 1</td>
</tr>
<tr>
<td valign=top>7</td><td valign=top>Optional memory size (default 200k)</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>None</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>254</td><td valign=top>Subspace is whole space</td>
</tr>
</table>
Commentary: This is really just a script to wrap up the relevant use
of <a href="#ztmu">ztmu</a>, <a href="#zss">zss</a> and <a
href="#zqs">zqs</a> for the same parameters.
</li>
<li>
<h3><a name="three">three</a></h3>
Purpose: Given a name *_1, produce *_3
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The name *_1</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The name *_3</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: A useful script when one wishes to perform the same
operations eg for several irreducibles, and one has used either
wildcarding or filename completion to produce a representative for
each. Eg for x in irreds/*_1; do signature $x `two $x` `three $x`;
done
</li>
<li>
<h3><a name="tspin_vectors">tspin_vectors</a></h3> Purpose: A version
of <a href="#spin_vectors">spin_vectors</a> where the generators are
supplied as a tensor product
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>A set of vectors to be tried</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>The number of vectors to be used</td>
</tr>
<tr>
<td valign=top>3</td><td valign=top>A file stem for the group generators in the left hand
tensor</td>
</tr>
<tr>
<td valign=top>4</td><td valign=top>A file stem for the group generators in the right hand
tensor</td>
</tr>
<tr>
<td valign=top>5</td><td valign=top>The amount of memory to use for <a
href="#zmsp">zmsp</a></td>
</tr>
<tr>
<td valign=top>6</td><td valign=top>The number of the first vector to be used</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>Information about each vector tried</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
<tr>
<td valign=top>2</td><td valign=top>Insufficient memory for workspace</td>
</tr>
<tr>
<td valign=top>255</td><td valign=top>No subspaces found</td>
</tr>
</table>
Commentary: This script is intended for searching a set of vectors for
one generating a small subspace. The typical use situation is where one knows
theoretically that one of the vectors will produce a small subspace,
and one knows a bound for the dimension of that subspace, and one
wishes to avoid other potentially much larger subspaces. A particular
case is where the subspace sought is an irreducible, and spinning
until closure might equally well produce the corresponding head, ie
the whole space. This situation is quite common in the case of tensor
products.
</li>
<li>
<h3><a name="two">two</a></h3>
Purpose: Given a name *_1, produce *_2
<table>
<thead>
<td valign=top>Parameters:</td>
</thead>
<tr>
<td valign=top>1</td><td valign=top>The name *_1</td>
</tr>
<tr>
<td valign=top>Textual output on stdout:</td><td valign=top>The name *_2</td>
</tr>
</table>
<table>
<thead>Return codes:</thead>
<tr>
<td valign=top>0</td><td valign=top>Success</td>
</tr>
<tr>
<td valign=top>1</td><td valign=top>Some sort of error, reported textually by the program</td>
</tr>
</table>
Commentary: A useful script when one wishes to perform the same
operations eg for several irreducibles, and one has used either
wildcarding or filename completion to produce a representative for
each. Eg for x in irreds/*_1; do signature $x `two $x`; done
</li>
</ul>
<a name="Caveats">
<h1>Caveats, folk lore and common usage</h1>
</a>
<p>
This section just consistes of a few pieces of wisdom I have picked up
on the way, and which may help others get to the results they want
more easily.
</p>
<ul>
<li>
Choose vectors for spinning carefully. Nullspace operations are
expensive in large dimensions, so you need to avoid the common
pathologies of either no null vectors or too many. Careful sudy of
known representations, plus the use of <a
href="#find_element">find_element</a> can assist in the decision
making here. Condensation, if I had it, would also assist greatly.
</li>
<li>
Don't multiply large dense matrices. Matrices from standard base,
tensor products and symmetrized powers are often pretty sparse, and so
multiplication with one of these on the left can be quite quick.
Contrast this with the situation where the matrix is the result of a
quotient or subspace operation. I made the mistake of doing this in
about 120000 dimensions while studying Co2. The multiplication took
over a day. If you need a complicated group algebra element, as
suggested by <a href="#find_element">find_element</a>, create it in
the initial representation (often a permuation, tensor product or
symmetrized power). Don't forget that tensoring and symmetrized powers
commute with the group operations (but not with group algebra
addition). Having acquired your complex element in the big
representation, pull it throught the relevant sub and quotient spaces
operations, plus transposes, until you have the desired element in the
relevant representation.
</li>
<li>
If your right hand operand in a matrix multiply is sparse, but the
left one isn't, considering transposing, performing the multiply in
the opposite order, and then transposing the result. Remember that
matrix multiply operates by adding rows, and which rows are added is
dictated by the non-zeros in the left hand operand. Having a left hand
operand which is mainly zero is a big win. Don't forget that tranpose
is quadratic in dimension, whereas multiply is cubic. The bigger the
dimension, the more worthwhile this trick is.
</li>
<li>
The worst size subspace to split with is about half the space. At this
point, quotient is at its most expensive, and the multiply preceding
the subspace operation has many rows, and at most half of any row is
sparse. Both very small and very large subspaces do well with
quotient, because its time depends on the product of the dimension and
codimension. Very small subspaces work well with multiply as there
aren't many rows. Very large subspaces also work well, because the
subspaces are echelised, and therefore each row contains a 1, a lot of
zeroes and a bit of random junk on the end. Hence we are now using a
sparse left hand operand. <a href="#zss">zss</a> is quadratic and
rarely dominates.
</li>
<li>
Keep all subspaces used in splitting a representation, and keep a
careful record of how the split proceeded. Firstly this helps in the
avoiding large matrix multiplies trick above. Secondly, it gives you
the opportunity to perform that trick reliably. And getting the
correct set of composition factors out at the end is a useful check
that you haven't boobed somewhere in the middle.
</li>
<li>
Never try to use more real memory than is available. If you let a VM
system take over, your programs will never terminate. Matrix
operations make mincemeat of VM and paging systems, causing thrashing
and usages of around 0.5% instead of the 99% you want. Using the file
based versions <a href="#znsf">znsf</a>, <a href="#zrnf">zrnf</a>, <a
href="#zmspf">zmspf</a>, <a href="#zmsbf">zmsbf</a>, <a
href="#ztspf">ztspf</a> will give nearly as good performance as the
all in memory equivalents, with one caveat, made in the next point.
</li>
<li>
Don't write large amounts of data across NFS. Firstly, it's not what
NFS was designed for, and it doesn't make a very good job of it.
Secondly, even a 100Mbit ethernet has nowhere near the throughput of
even an IDE disc, let alone a SCSI system. Reading across NFS doesn't
do too badly, as often the buffer cache will hold data repeatedly
read. But, if at all possible, do large data manipulations on a disc
local to the machine performing the computation.
</li>
<li>
Think carefully about the amount of space you make available for
operations such as multiply. More is not always better. For example,
whilst looking into the performance on some 20000 square matrices
obtained from the exploded monster generator A, I obtained the
(initially) surprising result that the best amount of memory to make
available was about 400kb (yes, four hundred kilobytes), even though
the matrices occupy 50Mb on disc. Increasing the memory gradually made
things worse, until at around 100Mb (when we could get all of the left
hand operand and the result into memory at once, and had only to read
through the right hand operand once), the time taken was around double
that taken at 400k. I believe the explanation for this phenomen has
two parts. The first is that with 400k available, we almost never went
outside the CPU cache. With 100Mb available, the CPU cache would be
rendered far less effective. Measuring CPU cache usage isn't easy,
it's not the kind of information that a profiler will display.
Secondly, I think 50Mb is somewhere around the buffer cache size for a
local linux filesystem. So it seems likely to me that the matrix that
is reread a lot (the right hand operand) is probably permanently in
the buffer cache, and the disc is never accessed for it. This
suspicion is further confirmed by the observation that it doesn't seem
to matter if the right hand operand is on an NFS mounted file system.
Indeed, with 400kb of memory, about 10% of which is allocated to the
right hand operand (ie 40kb), one would need to reread the right hand
operand somewhat more than 1000 times for a multiply, and the timings
I obtained (about 160 seconds wall clock) for 50Gb of data transfer
would indicate 300Mb per second, well beyond the capability of a
100Mbit Ethernet! There's a paper on memory managemewnt waiting to be
written on this sort of thing.
</li>
</ul>
</body>
</html>
